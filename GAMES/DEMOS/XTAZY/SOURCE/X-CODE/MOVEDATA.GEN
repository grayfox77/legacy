
;-------------------------------------------------------
;
;	MAKE ACTION
;
;	IN:	A,DE,HL
;	OUT:	make animation all sprites
;	MOD:	all
;
make_action:

	ld	(create_number),a	; save parameters of "action" call
	ld	(save_Y),de
	ld	(save_X),hl

	ld	hl,(Scroller_x) 	; calculate scroller motions
	ld	de,(save_x_scroll)	; load old scroll
	ld	(save_x_scroll),hl	; save new scroll
	or	a
	sbc	hl,de
	ld	a,l
	neg
	ld	(scrol_motion +0),a	; save X motion scroll

	ld	hl,(Scroller_y) 	; calculate Y roller
	ld	de,(save_y_scroll)	; load old scroll
	ld	(save_y_scroll),hl	; save new scroll
	or	a
	sbc	hl,de
	ld	a,l
	neg
	ld	(scrol_motion +1),a	; save Y roller


	ld	ix,zone_of_life

	ld	e,(ix +00)		; if zero then no life
	ld	d,(ix +01)

	ld	a,e
	or	d
	jr	z,make_birth		; zero then jump in birth

	ld	(next_personage),de	; save old jumper
	add	ix,de			; jump in next personage

loop_an:
	push	ix
	call	start_animes		; personages movers
	pop	ix

	ld	e,(ix +13)		; read in DE. jumper of personage
	ld	d,(ix +14)

	ld	a,(ix +00)		; test personage number
	or	a
	jr	z,no_nxt		; if zero then no save old jumper

	ld	(next_personage),de	; save old jumper

no_nxt:
	add	ix,de			; new position

	ld	a,e
	or	d
	jr	nz,loop_an		; if zero then end mover

bakdead:
	xor	a			; bigbang reset
	ld	(bigbang),a


;-------------------------------------------------------
;
;	MAKE BIRTH (faire une naissance)
;
;	IN:	none
;	OUT:	make birth sequences animations
;	MOD:	?
;
make_birth:

	ld	a,(create_number)	; if zero then no create
	or	a
	ret	z

	cp	255			; if 255 then personages string mode
	jr	nz,no_string


; string creates system

	ld	de,2			; init
	ld	hl,zone_of_life
	ld	(string_address),hl

	ld	hl,create_datas 	; datas address


loop_creates:
	ld	a,(hl)			; personage number
	or	a			; if zero then end create
	ret	z

	push	de

	ld	(create_number),a
	inc	hl

	ld	e,(hl)			; Y position
	inc	hl
	ld	d,(hl)
	inc	hl
	ld	(save_Y),de

	ld	e,(hl)			; X position
	inc	hl
	ld	d,(hl)
	inc	hl
	ld	(save_X),de

	ld	ix,(string_address)	; zone of lifes address actual

	pop	de

	push	hl			; save datas address
	call	please_creates
	pop	hl

	ld	de,15
	jr	loop_creates

no_string:


; search free position in "zone of life"

	ld	ix,zone_of_life
	ld	de,2			; first jumper +2 bytes for begin

please_creates:

loop_bb:
	ld	a,(ix +01)		; if zero then free position
	or	a
	jr	nz,no_free

	ld	a,(ix +00)
	or	a
	jr	z,ys_free

	cp	10h			; if > 15 then free position
	jr	nc,ys_free

no_free:
	ld	de,15			; second jumper +15 bytes
	add	ix,de

	jr	loop_bb 		; next position

ys_free:
	ld	l,(ix +00)		; free position found
	ld	h,(ix +01)

	ld	(ix +00),e		; new jumper for old personage (2or15)
	ld	(ix +01),d

	ld	bc,15
	add	ix,bc			; new position for new personage

	ld	a,h			; second jumper =0 then end string
	or	l
	jr	nz,nxt_fre

	ld	e,0			; reset old jumper

nxt_fre:
	or	a			; save new jumper at new personage
	sbc	hl,de

	ld	(ix +00),l
	ld	(ix +01),h

	ld	(string_address),ix	; save address for string creates

; enter news parameters for new personage

	ld	a,(create_number)	; personage number
	ld	(ix -13),a

	ld	l,a			; calculate data address of personage
	ld	h,0
	add	hl,hl

	ld	de,personages_dat
	add	hl,de			; personage number *2 + "pers_datas"

	ld	e,(hl)			; second data address in fisrt address
	inc	hl
	ld	d,(hl)

	ld	a,(de)			; flags
	ld	(ix -12),a
	inc	de

	ld	a,(de)			; sprites number.
	ld	(ix -11),a
	inc	de

	ld	a,(de)			; test conditions address.
	ld	(ix -10),a
	inc	de
	ld	a,(de)
	ld	(ix -09),a
	inc	de

	ex	de,hl			; new data address in HL. old in DE.

	ld	c,(hl)			; moving sequence address
	inc	hl
	ld	b,(hl)
	inc	hl

	dec	bc
	dec	bc

	ld	(ix -06),c
	ld	(ix -05),b

	ld	(ix -02),1		; 1 for timer moving


	ld	c,(hl)			; pattern sequence address
	inc	hl
	ld	b,(hl)
	inc	hl

	dec	bc
	dec	bc

	ld	(ix -04),c
	ld	(ix -03),b

	ld	(ix -01),1		; 1 for timer pattern

	push	hl			; save data address of personage


; search free position in attributes sprites table.

	ld	hl,all_sp_data +496	; last sprite position table
nxt212:
	ld	b,(ix -11)		; number sprites
loop212:
	ld	a,(hl)			; Y position

	dec	hl			; next position
	dec	hl
	dec	hl
	dec	hl

	cp	212			; if not 212 then not free
	jr	nz,nxt212

	djnz	loop212 		; B. = zero then free position

	inc	hl			; address right
	inc	hl
	inc	hl
	inc	hl

	ld	(ix -08),l		; save address at personage and IY.
	ld	(ix -07),h
	push	hl
	pop	iy

	ld	bc,all_sp_data		; Calculate address of second Y
	or	a
	sbc	hl,bc
	srl	h			; hl / 2
	rr	l
	ld	bc,auxiliary_Y		; second Y table
	add	hl,bc			; second address in HL.


	pop	de			; load data address of personage


; set sprites attributes of personage

	ld	a,(ix -11)		; number sprites of personage

	push	hl			; IY. attibutes table, IX.= second Y
	pop	ix
loop_position:

	ex	af,af'

	ld	hl,(save_Y)		; position on 16 bits
	ld	a,(de)			; add mover
	inc	de

	ld	c,a			; carry if negative
	add	a,a
	sbc	a,a
	ld	b,a
	add	hl,bc			; to add up or to subtract

	ld	(ix +00),l		; new sprite position for Y
	ld	(ix +01),h
	ld	(iy +00),213		; sprite disable


	ld	hl,(save_X)		; position on 16 bits
	ld	a,(de)			; add mover
	inc	de

	ld	c,a			; carry if negative
	add	a,a
	sbc	a,a
	ld	b,a
	add	hl,bc			; to add up or to subtract

	ld	(iy +2),l		; new sprite position for X on 10 bits
	ld	a,h
	and	%00000011
	ld	(iy +3),a

	inc	ix			; next sprite attributes.
	inc	ix

	inc	iy
	inc	iy
	inc	iy
	inc	iy

	ex	af,af'                  ; if A. = zero then end
	dec	a
	jr	nz,loop_position


loop_cr_others:
	ld	a,(de)			; zero if last personage
	inc	de
	ld	(create_number),a	; zero = reset personage number

	or	a
	ret	z			; end creates


; creates others personages

	ld	hl,(save_Y)		; position on 16 bits
	ld	a,(de)			; add mover
	inc	de
	ld	c,a			; carry if negative
	add	a,a
	sbc	a,a
	ld	b,a
	add	hl,bc			; to add up and to subtract
	ld	(save_Y),hl


	ld	hl,(save_X)		; position on 16 bits
	ld	a,(de)			; add mover
	inc	de
	ld	c,a			; carry if negative
	add	a,a
	sbc	a,a
	ld	b,a
	add	hl,bc			; to add up and to subtract
	ld	(save_X),hl

	ld	ix,(string_address)	; zone of lifes address actual
	push	de
	ld	de,15
	call	please_creates
	pop	de

	jr	loop_cr_others


start_animes:
	ld	(save_stack),sp 	; save stack pointer for return

;-------------------------------------------------------
;
;	MAKE BIGBANG
;
;	IN:	none
;	OUT:	kill all sprites animations (sprites enables only)
;	MOD:	?
;
make_bigbang:
	ld	a,(bigbang)		; zero then no bigbang
	or	a
	jr	z,no_bigbang

	ld	a,(ix +03)		; no condition address then no bigbang
	or	  (ix +04)
	jr	z,no_bigbang

	bit	7,(ix +01)		; if personage disable then no bigbang
	jr	nz,no_bigbang

	ld	h,0			; calculate data bigbang address
	ld	l,(ix +00)
	ld	de,data_bigbang

	dec	l
	add	hl,hl
	add	hl,de

	ld	e,(hl)			; HL. data bigbang address
	inc	hl
	ld	d,(hl)

	ld	a,e			; (HL). = 0 then no bigbang
	or	d

	call	nz,chg_sequence 	; change parameters of personage

no_bigbang:

;-------------------------------------------------------
;
;	MAKE PATTERNS ANIMATIONS OF SPRITES (+attribute)
;
;	IN:	none
;	OUT:	make animation patterns
;	MOD:	?
;
anime_pattern:

	ld	l,(ix +05)		; IX. position in zone of life
	ld	h,(ix +06)
	push	hl
	pop	iy			; IY. position in sprite table

	ld	b,(ix +12)		; timer of patterns
	djnz	no_chg_pattern

	ld	l,(ix +09)		; pattern sequence address
	ld	h,(ix +10)

	inc	hl			; next sequence
	inc	hl

	ld	e,(hl)			; sequence address
	inc	hl
	ld	d,(hl)

	ld	a,d			; address = -1 then dead sequence
	cp	255
	jp	z,dead_sequence

 ; sound effects
	cp	254			; address = -2 then sound effects
	jr	nz,no_play_effect

	ld	a,(iy +02)
	rrca
	rrca
	rrca
	rrca
	and	#0f		;make sure result is: 0 <= result < 16
	or	#80		;non interuptible sound effect

	push	hl
	ld	b,a
	ld	a,e		;sound effect number
	call	Sound_Effect	;activate "explode" sound effect
	pop	hl

	inc	hl
	inc	hl
	ld	e,(hl)			; sequence address
	inc	hl
	ld	d,(hl)

no_play_effect:
	dec	hl

	ld	a,e			; address = 0 then jump other sequence
	or	d
	jr	nz,jump_other_pat

	inc	hl			; next sequence address
	inc	hl

	ld	e,(hl)
	inc	hl
	ld	d,(hl)

	ex	de,hl

	ld	e,(hl)			; new pattern address
	inc	hl
	ld	d,(hl)
	dec	hl

jump_other_pat:
	ld	(ix +09),l		; save new sequence address
	ld	(ix +10),h

	ld	a,(de)			; new timer
	ld	b,a
	inc	de

	ld	l,(ix +05)		; position in sprites attributes table
	ld	h,(ix +06)

	push	hl
	pop	iy

	push	hl
	push	bc

	ld	b,(ix +02)		; number sprites

	ld	a,(de)			; mode (0 or 1)
	inc	de

	ex	de,hl
	or	a
	jr	nz,pattern_mode1

loop_pat_mode0:
	ld	a,(hl)			; set pattern number
	inc	hl
	ld	(iy +1),a

	ld	a,(iy +3)		; set palette number + screen number
	and	%00000011
	or	(hl)
	inc	hl
	ld	(iy +3),a

	inc	iy			; next sprite
	inc	iy
	inc	iy
	inc	iy

	djnz	loop_pat_mode0
	jr	end_pattern

no_chg_pattern:
	ld	(ix +12),b		; timer patterns
	jr	moving_sprites

pattern_mode1:
	ld	e,(hl)			; get parameters
	inc	hl
	ld	d,(hl)

loop_pat_mode1:
	ld	(iy+1),e		; set pattern number
	inc	e

	ld	a,(iy +3)		; set palette number + screen number
	and	%00000011
	or	d
	ld	(iy +3),a

	inc	iy			; next sprite
	inc	iy
	inc	iy
	inc	iy

       djnz    loop_pat_mode1

end_pattern:
	pop	bc
	pop	iy

	ld	(ix +12),b		; timer patterns

;-------------------------------------------------------
;
;	MOVING ANIMATIONS SPRITES
;
;	IN:	none
;	OUT:	make moves all sprites
;	MOD:	?
;
moving_sprites:

	set	7,(ix +01)		; set desable personage flag

	ld	l,(ix +07)		; move sequence address.
	ld	h,(ix +08)

	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	inc	hl


	ld	b,(ix +11)		; timer of motions
	djnz	no_motions

	ld	e,(hl)			; new motions address
	inc	hl
	ld	d,(hl)
	dec	hl

	ld	a,d			; address = -1 then dead sequence
	cp	255
	jp	z,dead_sequence

	ld	a,e			; address = 0 then jump other sequence
	or	d
	jr	nz,jump_other_mov

	inc	hl			; next sequence address
	inc	hl

	ld	e,(hl)
	inc	hl
	ld	d,(hl)

	ex	de,hl

jump_other_mov:
	ld	(ix +07),l		; new motions address
	ld	(ix +08),h

	ld	e,(hl)
	inc	hl
	ld	d,(hl)

	ld	a,(de)			; new timer address
	ld	b,a

no_motions:
	ld	(ix +11),b

	ex	de,hl
	push	iy
	inc	hl

	ld	b,(ix +02)		; number sprites

	exx				; calculate Y extend address
	push	iy
	pop	hl

	ld	de,all_sp_data		; ((Y address) - (all_sp_data)) /2
	or	a
	sbc	hl,de

	srl	h
	rr	l

	ld	de,auxiliary_Y		; (auxiliary_Y) + result
	add	hl,de
	exx				; calculate end


	ld	a,(hl)			; mode selection 0 or 1 or 2
	cp	2
	jr	z,motions_mode2
	inc	hl
	cp	1
	jr	z,motions_mode1


; Premiere routine de mouvements.


motions_mode0:				; Y sprites motions

loop_mov_mode0:
	ld	a,(scrol_motion +1)	; add scrolling
	add	a,(hl)			; add motions
	call	set_motions_Y		; set motions
	inc	hl
					; X sprites motions
	ld	a,(scrol_motion +0)	; add scrolling
	add	a,(hl)			; add motions
	call	set_motions_X		; set motions

	inc	hl			; next sprite
	inc	iy
	inc	iy
	inc	iy
	inc	iy

	djnz	loop_mov_mode0
	jr	end_motions


; Deuxieme routine de mouvements.


motions_mode1:
	ld	d,(hl)			; motions datas
	inc	hl
	ld	e,(hl)

loop_mov_mode1: 			; Y sprites motions
	ld	a,(scrol_motion +1)	; add scrolling
	add	a,d			; add motions
	call	set_motions_Y		; set motions
					; X sprites motions
	ld	a,(scrol_motion +0)	; add scrolling
	add	a,e			; add motions
	call	set_motions_X		; set motions

	inc	iy			; next sprite
	inc	iy
	inc	iy
	inc	iy

	djnz	loop_mov_mode1
	jr	end_motions

; Troisieme routine de mouvements.

motions_mode2:
	dec	hl			; calculate motions address
	ld	a,(hl)
	sub	(ix +11)		; timer motions
	inc	hl
	inc	hl

	ex	de,hl
	ld	l,a
	ld	h,0
	add	hl,hl
	add	hl,de

	ld	d,(hl)			; motions data
	inc	hl
	ld	e,(hl)

loop_mov_mode2: 			; Y sprites motions
	ld	a,(scrol_motion +1)	; add scrolling
	add	a,d			; add motions
	call	set_motions_Y		; set motions

					; X sprites motions
	ld	a,(scrol_motion +0)	; add scrolling
	add	a,e			; add motions
	call	set_motions_X		; set motions

	inc	iy			; next sprite
	inc	iy
	inc	iy
	inc	iy

	djnz	loop_mov_mode2

end_motions:
	pop	iy


;-------------------------------------------------------
;
;	TESTING ALL SPRITES
;
;	IN:	none
;	OUT:	to be or not to be?
;	MOD:	?
;

testing_spr:
	bit	7,(ix  +01)
	ret	nz

	ld	l,(ix +03)		; test conditions address
	ld	h,(ix +04)

	ld	a,l
	or	h
	ret	z

	ld	e,(hl)			; jump address if testing is true
	inc	hl
	ld	d,(hl)
	inc	hl
	ld	(address_test),de	; set address

	xor	a
	ld	(number_tests),a

loop_test:
	ld	a,(hl)			; if 255 then no tests
	inc	hl
	cp	255
	ret	z

;	 cp	 1
;	 jr	 z,testing_mode1

testing_mode0:
	ld	a,(hl)			; sprite address test in attribute
	ld	(sprite_test),a
	inc	hl

	push	hl			; sauve data address

	ld	l,a			; calculate sprite address to test
	ld	h,0
	add	hl,hl
	add	hl,hl
	ld	de,all_sp_data
	add	hl,de
	ld	(pattern_adress),hl

	push	hl			; sprite offset test

	inc	hl			; pattern sprite number
	ld	l,(hl)
	ld	h,0
	add	hl,hl
	ld	de,offset_sprites
	add	hl,de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)

	pop	hl

	ld	a,(ix +02)		; number sprites

	push	iy			; personage position

loop_sprite:
	ex	af,af'
	push	hl

	ld	a,(iy +03)		; if sprite desable then no tests
	and	%00000011
	jr	nz,no_touch

	ld	a,(hl)
	or	(iy +00)
	add	a,16
	cp	228
	jr	nc,no_touch

	ld	a,(iy+0)		; if Y sprite is touched then test X
	sub	(hl)
	ld	b,e
	jr	nc,positive_Y
	ld	b,16
	neg
positive_Y:
	cp	b
	jr	nc,no_touch

	inc	hl			; if X sprite is touched
	inc	hl

	ld	a,(iy+2)
	sub	(hl)
	ld	b,d
	jr	nc,positive_X
	ld	b,16
	neg
positive_X:

	cp	b
	jr	nc,no_touch

	call	collision_spr

no_touch:
	inc	iy			; next sprite
	inc	iy
	inc	iy
	inc	iy

	pop	hl
	ex	af,af'
	dec	a
	jr	nz,loop_sprite

	pop	iy			; next test

	ld	hl,number_tests
	inc	(hl)

	pop	hl

	jr	loop_test

; collision sprites with personage and results

collision_spr:
	push	de			; save data address

	ld	a,(sprite_test) 	; special test for x-tazy-fire
	sub	19
	cp	6
	jr	nc,no_tazy_fire

	ld	e,a
	ld	d,0
	ld	hl,fire_status
	add	hl,de

	ld	(hl),0

	ld	hl,(pattern_adress)
	ld	(hl),212

no_tazy_fire:
	ld	de,(address_test)	; calculate datas address test
	ld	hl,number_tests
	ld	l,(hl)
	ld	h,0
	add	hl,hl
	add	hl,de

	ld	e,(hl)			; results data address
	inc	hl
	ld	d,(hl)

	call	chg_sequence		; change paramerters

	pop	de

	ld	a,(hl)			; next test
	or	a
	ret	z

	ld	sp,(save_stack) 	; end tests
	ret

;-------------------------------------------------------
;
;	CHANGE DATAS PARAMETERS OF PERSONAGE
;
;	IN:	none
;	OUT:	change destiny of personage (dead or change sequence)
;	MOD:	?
;
chg_sequence:
	ex	de,hl

	ld	e,(hl)			; new pattern sequence address
	inc	hl
	ld	d,(hl)
	inc	hl

	ld	a,d
	or	a
	jp	z,dead_sequence

	cp	255
	jr	z,no_change_pat

	ld	(ix +09),e
	ld	(ix +10),d

	push	hl
	ex	de,hl

	ld	e,(hl)			; new timer patterns sequence
	inc	hl
	ld	d,(hl)

	ld	a,(de)
	ld	(ix +12),a
	pop	hl


no_change_pat:
	ld	e,(hl)			; new moving sequence address
	inc	hl
	ld	d,(hl)
	inc	hl

	ld	a,d
	cp	255
	jr	z,no_change_mov

	ld	(ix +07),e
	ld	(ix +08),d

	push	hl
	ex	de,hl

	ld	e,(hl)			; new timer motions sequence
	inc	hl
	ld	d,(hl)

	ld	a,(de)
	ld	(ix +11),a
	pop	hl


no_change_mov:
	ld	e,(hl)			; new test conditions address
	inc	hl
	ld	d,(hl)
	inc	hl

	ld	(ix +03),e
	ld	(ix +04),d
	ret

;-------------------------------------------------------
;
;	SET X MOTIONS PARAMETERS OF SPRITES
;
set_motions_X:

	exx
	ex	de,hl

	ld	c,a			; carry if negative
	add	a,a
	sbc	a,a
	ld	b,a

	ld	l,(iy +2)		; position on 16 bits
	ld	a,(iy +3)
	and	%00000011
	ld	h,a

	add	hl,bc			; to add up or to subtract


; if sprite is screen out

	ld	a,h			; mask plt and scr of sprite
	and	%00000011
	ld	h,a

	cp	3			; if <-128 or >512 then dead.
	jr	nz,X_is_others
	ld	a,l
	cp	128
	jp	c,dead_sequence

	cp	240			; if <-16 or >256 then out screen
	jr	c,X_out_screen
	jr	X_no_out

X_is_others:
	or	a
	jr	z,X_no_out
	cp	1
	jr	nz,X_no_out
	ld	a,l
	cp	128
	jr	nc,dead_sequence

X_out_screen:				; desable personage
	ld	(iy +0),213
	set	7,(ix +01)

X_no_out:				; enable personage
	ld	a,(iy +3)
	and	%11110000
	or	h
	ld	(iy +3),a
	ld	(iy +2),l

	ex	de,hl
	exx
	ret

;-------------------------------------------------------
;
;	SET Y MOTIONS PARAMETERS OF SPRITES
;
set_motions_Y

	exx

	ld	c,a			; carry if negative
	add	a,a
	sbc	a,a
	ld	b,a

	ld	e,(hl)			; position on 16 bits
	inc	hl
	ld	d,(hl)
	dec	hl

	ex	de,hl			; to add up or to subtract
	add	hl,bc
	ex	de,hl


; if sprite is screen out

	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl

	ld	a,d			; if <-256 or >512 then dead
	cp	255
	jr	nc,Y_is_others
	cp	2
	jr	nc,dead_sequence

Y_is_others:
	or	a
	jr	nz,is_others
	ld	a,e
	cp	212
	jr	c,Y_no_out

is_others:
	ld	a,d
	cp	255
	jr	nz,Y_out_screen 	; if <-16 or >256 then out screen
	ld	a,e
	cp	240
	jr	nc,Y_no_out

Y_out_screen:				; desable personage
	ld	e,213
	ld	(iy +0),e
	exx
	ret

Y_no_out:				; enable personage
	ld	(iy +0),e
	res	7,(ix +01)

	exx
        ret


;-------------------------------------------------------
;
;	DEAD SEQUENCE
;
;	IN:	none
;	OUT:	...
;	MOD:	?
;
dead_sequence:
	ld	sp,(save_stack) 	; load stack for return

; Y sprites position in 212

	ld	l,(ix +05)		; Y position
	ld	h,(ix +06)
	ld	b,(ix +02)		; number sprites
	ld	de,4

loop_dead:
	ld	(hl),212
	add	hl,de
	djnz	loop_dead

; set new jump

	ld	l,(ix +13)		; real jump
	ld	h,(ix +14)
	ld	bc,(next_personage)	; old jump
	ld	(ix +00),0		; number sprite to zero for dead flag

	push	bc

	ld	a,h			; is zero then last personage jump
	or	l
	jr	nz,no_last_sprite
	ld	bc,0			; reset old jump
	ld	hl,0

no_last_sprite:
	add	hl,bc			; set new jump in DE. and "nxt_psr"
	ex	de,hl
	ld	(next_personage),de

	pop	bc

	push	ix			; jump to before personage
	pop	hl
	or	a
	sbc	hl,bc
	push	hl
	pop	ix

	ld	bc,zone_of_life 	; if IX.= zone of life address
	ld	a,b
	cp	h
	jr	nz,no_equal
	ld	a,c
	cp	l
	jr	nz,no_equal

					; if IX.= zone of life address
	ld	(ix +00),e		; set new jump
	ld	(ix +01),d
	ret				; end personage
no_equal:
	ld	(ix +13),e		; set new jump
	ld	(ix +14),d
	ret				; end personage

;-------------------------------------------------------
;
;	DATAS ZONE
;


; datas exchange for names

none:		equ	 0
jump:		equ	 0
dead:		equ	-1
mode0:		equ	 0
mode1:		equ	 1
mode2:		equ	 2
deads:		equ	 0
no_chg: 	equ	-1
stop:		equ	 1
cont:		equ	 0
end_test:	equ	-1
sound:		equ	254 * 256

; communications datas

bigbang:	defb	0		; bigbang flag

number_tests:	defb	0
sprite_test:	defb	0
pattern_adress: defw	0

create_number:	defb	0		; creation datas
string_datas:
save_X: 	defw	00000h
save_Y: 	defw	00000h

string_address: defw	00000h		; for creates string


save_y_scroll:	defw	0
save_x_scroll:	defw	0
scrol_motion:	defw	00000h		; scroll motions XY
address_test:	defw	00000h
next_personage: defw	00000h		; jumper save data
save_stack:	defw	00000h

create_datas:	defs	50		; maxi 25 creates personages in 1 time

; personality of personage

personages_dat: defw	none		; personage data address
		defw	personage01
					; parameters of personage
personage01:	defb	%10000000
		defb	002h
		defw	cond01, move01, side01
		defb	+00,+00,   +00,+16
		defb	0		; stop creates

;		defb	2		; create other personage
;		defb	+00,+32 	; with others positions


; bigbang data
					; if address zero then no bigbang

data_bigbang:	defw	 none,	none,  none,  none
		defw	 none,	none,  none,  none


; patterns animations datas
					; patterns sequence address

side01: 	defw	   pic01,     jump,	side01
side05: 	defw	   pic07, sound+07,	dead

; patterns sequences
					; timing, mode, picture, pal + plan

pic01:		defb	064, mode1, 04, 80h
pic02:		defb	064, mode1, 04, 80h
pic03:		defb	064, mode1, 04, 80h

pic07:		defb	001, mode1, 04, 80h


; motions animations datas
					; motions sequence address

move01: 	defw	mv01, mv02, mv03, jump,move01

; motions sequences
					; time, mode, Y, X

mv01:		defb	255, mode1, +00, +01
mv02:		defb	255, mode1, +00, +01
mv03:		defb	255, mode1, +00, +01

;mv09:		 defb	 003, mode2
;		 defb	 +01,-01,+00,-01, +00,-01, +00,-1
;mv10:		 defb	 000, mode1, +00, -00


; tests datas of personages
					; address, mode, sprite, end/mode
cond01: 	defw	test_true_01
		defb	mode0, 19
		defb	mode0, 20
		defb	mode0, 21
		defb	mode0, 22
		defb	mode0, 23
		defb	mode0, 24
		defb	end_test

test_true_01:	defw	c3_00, c3_00, c3_00, c3_00,c3_00,c3_00


; datas changes if testing is true
					; pat, mov, test, (stop/cont)

c3_00:		defw	deads, move01,	 none,stop

; offset for sprites tests

offset_sprites: defb	+16,16		; 0
		defb	+16,16
		defb	+16,16
		defb	+16,16
		defb	+16,16
		defb	+16,16
		defb	+16,16
		defb	+16,16

		defb	+16,16		; 8
		defb	+16,16
		defb	+16,16
		defb	+16,16
		defb	+16,16
		defb	+16,16
		defb	+16,16
		defb	+16,16

		defb	+16,16		; 16 missile
		defb	+16,16		; 17 missile
		defb	+03,08		; 18 gun
		defb	+03,16		; 19 laser
		defb	+16,16
		defb	+16,16
		defb	+16,16
		defb	+16,16

		defb	+15,15		;24

auxiliary_Y:	defs	125 * 2

; free datas zone for personages creates

zone_of_life:
	defw	none
	defs	15 * 25 		; bytes * personages
