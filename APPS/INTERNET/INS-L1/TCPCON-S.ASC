	;--- Consola TCP para InterNestor Lite 1.03
	;    Por Konami Man, 4-2005
	;    Uso: TCPCON <nombre host>|<dir IP> <puerto remoto> [<puerto local>] [P]
	;         Anyadir P para abrir la conexion en modo pasivo
	;         Usar la IP 0.0.0.0 para dejar el socket remoto sin especificar

	;Este programa abre una conexion TCP al host especificado
	;en el puerto especificado (opcionalmente una conexion pasiva),
	;y entra en un bucle en el que todos los datos recibidos se
	;imprimen por pantalla, y todo lo que se teclea se envia
	;a la conexion, hasta que cerramos la conexion (pulsando ESC)
	;o la cierra el host remoto.

	;Notese que esto NO es un cliente de Telnet, dado que
	;no se procesan los caracteres especiales que forman parte
	;de la especificacion de Telnet (los datos recibidos
	;se imprimen tal cual en pantalla, y los datos tecleados
	;se envian tal cual a la conexion).

	.label	20	;Directiva para Compass


;*****************************
;***                       ***
;***  MACROS Y CONSTANTES  ***
;***                       ***
;*****************************

DOS:	equ	#0005	;Punto de llamada a las funciones del DOS

	;--- Macro para imprimir una cadena terminada en "$"

print:	macro	@d
	ld	de,@d
	ld	c,_STROUT
	call	DOS
	endm

	;--- Macro para llamar a una funcion de InterNestor Lite.
	;
	;    Bajo DOS 1, tras una llamada a cualquier funcion del DOS
	;    el sistema restaura el segmento de TPA en la pagina 1,
	;    cosa que no ocurre bajo DOS 2.
	;
	;    Usando esta macro nos aseguramos de que las llamadas
	;    a INL siempre se efectuan correctamente.

inl:	macro	@d
	push	af
	ld	a,(INL_SEG1)
	call	PUT_P1
	pop	af

	call	@d
	endm

	;--- Funciones del DOS

_TERM0:	equ	#00	;Program terminate
_CONIN:	equ	#01	;Console input with echo
_CONOUT:	equ	#02	;Console output
_DIRIO:	equ	#06	;Direct console I/O
_INNOE:	equ	#08	;Console input without echo
_STROUT:	equ	#09	;String output
_BUFIN:	equ	#0A	;Buffered line input
_CONST:	equ	#0B	;Console status
_TERM:	equ	#62	;Terminate with error code
_DEFAB:	equ	#63	;Define abort exit routine
_DOSVER:	equ	#6F	;Get DOS version

	;--- Variables y rutinas de InterNestor Lite

IP_STRING:	equ	#4036	;Convierte una IP en una cadena
DNS_Q:	equ	#405D	;Efectua peticion DNS
DNS_S:	equ	#4060	;Obtiene respuesta DNS
TCP_OPEN:	equ	#4063	;Abre una conexion TCP
TCP_CLOSE:	equ	#4066	;Cierra una conexion TCP
TCP_ABORT:	equ	#4069	;Aborta una conexion TCP
TCP_SEND:	equ	#406C	;Envia datos a una conexion TCP
TCP_RCV:	equ	#406F	;Recibe datos desde una conexion TCP
TCP_STATUS:	equ	#4072	;Obtiene el estado de una conexion TCP
TCP_FLUSH:	equ	#4075	;Elimina los datos a enviar de una conexion TCP
WAIT_INT:	equ	#4081	;Espera a la siguiente interrupcion del reloj
NETWORK_STATE:	equ	#4084	;Comprueba el estado de la red


;****************************
;***                      ***
;***  PROGRAMA PRINCIPAL  ***
;***                      ***
;****************************

	org	#100	;Necesario para los programas que se ejecutan en MSX-DOS

	;------------------------
	;---  Inicializacion  ---
	;------------------------

	;--- Comprueba la version del DOS y establece la variable DOS2

	ld	c,_DOSVER
	call	DOS
	or	a
	jr	nz,NODOS2
	ld	a,b
	cp	2
	jr	c,NODOS2

	ld	a,#FF
	ld	(DOS2),a	;#FF para DOS 2, 0 para DOS 1
NODOS2:	;

	;--- Imprime la presentacion

	print	PRESENT_S

	;--- Comprueba si hay parametros,
	;    si no los hay, muestra informacion y termina

	ld	a,1
	ld	de,BUFFER
	call	EXTPAR
	jr	nc,HAYPARS

TERMINFO:	print	INFO_S
	ld	c,_TERM0
	jp	DOS
HAYPARS:	;

	;--- Comprueba que InterNestor Lite este instalado, si no
	;    muestra un error y termina

	xor	a
	ld	de,#2203
	call	#FFCA
	or	a
	jr	nz,OKINS

	print	NOINS_S
	ld	c,_TERM0
	jp	DOS
OKINS:	;

	ld	a,b
	ld	(INL_SEG1),a
	;ld      a,c                    ;--- En este programa no necesitamos
	;ld      (INL_SEG2),a           ;--- esta informacion, nos basta
	;ld      (INL_P3DIR),hl         ;--- el numero del segmento de codigo

	;--- Obtiene PUT_P1 a partir
	;    de la zona de trabajo de INL en pagina 3
	;    (tiene offset 15); HL aun apunta a la zona de salto

	ld	bc,15
	add	hl,bc
	ld	de,PUT_P1
	ld	bc,3
	ldir

	;> Desde este punto podemos saltar a TERMINATE para volver al DOS.

	;--- Conecta el segmento de InterNestor Lite en pagina 1
	;    (No es necesario porque usamos la macro "inl")

	;ld     a,(INL_SEG1)
	;call   PUT_P1

	;--- Comprueba que realmente estemos conectados,
	;    en caso contrario muestra error y termina

	inl	NETWORK_STATE
	cp	2	;La red esta disponible?
	jr	z,CONNECT_OK

	print	ASTERISK_S
	print	NOCON_S+1
	print	ONE_NL_S
	jp	TERMINATE
CONNECT_OK:	;

	;--- Obtiene el nombre del servidor desde la linea de comandos

	ld	a,1
	ld	de,HOST_NAME
	call	EXTPAR

	;--- Obtiene el puerto remoto desde la linea de comandos

	ld	a,2
	ld	de,BUFFER
	call	EXTPAR
	jp	c,MISSPAR	;Error si falta el parametro

	ld	hl,BUFFER
	call	EXTNUM16
	jp	c,INVPAR	;Error si no es un numero valido

	ld	(PORT_REMOTE),bc

	;--- Obtiene otros parameters si los hay
	;    (puerto local y conexion pasiva)

	ld	a,3	;Numero de parametro a extraer
LASTPARAMS:	ld	ixh,a
	ld	de,BUFFER
	call	EXTPAR
	jr	c,NOMOREPARS	;El parametro esta presente?

	ld	a,(BUFFER)	;Si el primer caracter del parametro
	or	%00100000	;es "P" o "p", establecer apertura pasiva...
	cp	"p"
	jr	nz,NO_PASSIVE
	ld	a,#FF
	ld	(PASSIVE_OPEN),a
	jr	LASTPAR_NEXT
NO_PASSIVE:

	ld	hl,BUFFER	;...si no, si es un numero, establecer
	call	EXTNUM16	;el puerto local; si no, es un
	jp	c,INVPAR	;parametro invalido.
	ld	(PORT_LOCAL),bc

LASTPAR_NEXT	ld	a,ixh
	inc	a
	cp	5	;Extrae solo los parametros 3 y 4
	jr	c,LASTPARAMS
NOMOREPARS:	;

	;--- Si estamos en DOS 2, establecer la rutina para capturar
	;    CTRL-C y CTRL-STOP

	ld	a,(DOS2)
	or	a
	ld	de,CLOSE_END	;Desde ahora, pulsar CTRL-C
	ld	c,_DEFAB	;tiene el mismo efecto que pulsar CTRL-ESC
	call	nz,DOS		;(aborta la conexion TCP y termina el programa)


	;----------------------------------------------------------------------
	;---  Resolucion del nombre del host y apertura de la conexion TCP  ---
	;----------------------------------------------------------------------

	;>>> Resuelve el nombre del servidor

	print	RESOLVING_S

	ld	hl,HOST_NAME	;Consulta al resolver...
	xor	a
	inl	DNS_Q

	ld	b,a	;...y comprueba si hay error
	ld	ix,DNSQERRS_T
	jr	c,DNSQR_ERR

	;* Espera a que la consulta termine

DNSQ_WAIT:	inl	WAIT_INT
	call	CHECK_KEY	;Para permitir que el proceso
	;pueda ser abortado con CTRL-C

	ld	a,1
	inl	DNS_S

	;* Error?

	cp	3
	ld	ix,DNSRERRS_T
	jr	z,DNSQR_ERR

	;* La consulta continua? Volver al bucle de espera

	cp	2
	jr	nz,DNSQ_WAIT	;La consulta aun no ha terminado?

	;* La consulta ha terminado? Guardar y mostrar resultado, y continuar

	ld	(IP_REMOTE),hl	;Guarda el resultado devuelto (L.H.E.D)
	ld	(IP_REMOTE+2),de

	ld	ix,RESOLVIP_S	;Muestra el resultado
	ld	a,"$"
	inl	IP_STRING
	print	RESOLVOK_S
	print	TWO_NL_S

	jp	RESOLV_OK	;Continua

	;- Rutina de error para DNS_Q y DNS_S
	;  Entrada: B=Codigo de error, IX=Tabla de errores

DNSQR_ERR:	push	ix,bc

	;* Imprime "ERROR <codigo>: "

	ld	ix,RESOLVERRC_S
	call	BYTE2ASC
	ld	(ix),":"
	ld	(ix+1)," "
	ld	(ix+2),"$"
	print	RESOLVERR_S

	;* Obtiene la cadena de error, la imprime, y termina

	pop	bc,de
	call	GET_STRING
	ld	c,_STROUT
	call	DOS

	jp	TERMINATE
RESOLV_OK:	;


	;>>> Abre la conexion TCP

	ld	hl,(IP_REMOTE)
	ld	de,(IP_REMOTE+2)
	ld	ix,(PORT_REMOTE)
	ld	iy,(PORT_LOCAL)
	ld	a,(PASSIVE_OPEN)
	ld	bc,0
	inl	TCP_OPEN
	jr	nc,OPEN_OK

	push	af
	print	ERROR_S
	pop	af
	ld	b,a	;Error: muestra la causa y termina
	ld	de,TCPOPERRS_T
	call	GET_STRING
	ld	c,_STROUT
	call	DOS
	jp	TERMINATE

OPEN_OK:	ld	(CON_NUM),a	;No hay error: guarda id. de conexion
	print	OPENING_S

	;--- Espera a que la conexion quede establecida.
	;    Si se pulsa ESC mientras, se cierra la conexion
	;    y el programa termina.

WAIT_OPEN:	call	WAIT_INT
	ld	a,(#FBEC)	;El bit 2 de #FBEC es 0
	bit	2,a	;cuando se esta pulsando ESC
	jp	z,CLOSE_END

	ld	a,(CON_NUM)
	inl	TCP_STATUS
	or	a
	jr	nz,WAIT_OPEN2

	push	bc
	print	ONE_NL_S
	pop	bc
	ld	de,TCPCLOSED_T	;Si la conexion ha vuelto a CLOSED,
	call	GET_STRING	;muestra la razon y termina
	ld	c,_STROUT
	call	DOS
	jp	TERMINATE

WAIT_OPEN2:	cp	4	;4 = codigo para el estado ESTABLISHED
	jr	nz,WAIT_OPEN

	print	OPENED_S


	;-------------------------------------
	;---  Bucle de programa principal  ---
	;-------------------------------------

	;- Comprueba si hay datos entrantes, si es asi los imprime.
	;- Comprueba si se ha perdido el estado "established",
	;  de ser asi muestra "conexion cerrada por el host remoto"
	;  y termina.
	;- Comprueba si se esta pulsando ESC, si es asi,
	;  muestra "conexion cerrada/abortada" y termina.
	;- Comprueba si se esta pulsando F1/F2/F3,
	;  en ese caso procesa la pulsacion.
	;- Comprueba la pulsacion de otras teclas, si se han pulsado,
	;  obtiene un caracter o una linea (dependiendo del modo de entrada)
	;  y lo envia.
	;- Espera a la siguiente interrupcion del reloj (WAIT_INT)
	;  y repite el bucle.

MAIN_LOOP:	;

	;--- Intenta obtener datos entrantes y los imprime

	ld	a,(CON_NUM)
	ld	de,BUFFER
	ld	bc,1024
	inl	TCP_RCV
	jp	c,TCP_ERROR	;Error?
	jr	z,END_RCV	;No hay datos disponibles?
TCP_RCVOK:	;

	ld	hl,BUFFER

PRNTLOOP:	ld	a,(#FBEC)	;Si se pulsa ESC, terminar
	bit	2,a
	jp	z,CLOSE_END

	push	bc	;Imprime los datos caracter a caracter.
	ld	a,(hl)	;No podemos usar la funcion _STROUT,
	inc	hl	;ya que no sabemos si hay caracteres "$"
	push	hl	;en los datos a imprimir.
	ld	e,a
	ld	c,_CONOUT
	call	DOS
	pop	hl,bc
	dec	bc
	ld	a,b
	or	c
	jr	nz,PRNTLOOP
END_RCV:	;

	;--- Comprueba si la conexion ha perdido el estado
	;    ESTABLISHED. Si es asi, cierra la conexion
	;    y termina.

	ld	a,(CON_NUM)
	inl	TCP_STATUS
	cp	4	;Estado ESTABLISHED
	jr	z,STATUS_OK

	or	a	;Si esta cerrada, actuar como si
	ld	a,2	;TCP_xxx hubiera devuelto error 2
	jp	z,TCP_ERROR

	ld	a,(CON_NUM)	;En caso contrario, cerrar la conexion y mostrar
	inl	TCP_CLOSE	"Cerrada por el host remoto" antes de terminar
	print	TWO_NL_S
	print	PEERCLOSE_S+1
	jp	TERMINATE
STATUS_OK:

	;--- Comprueba si se esta pulsando ESC, si es asi,
	;    cerrar o abortar la conexion y terminar

	ld	a,(#FBEC)
	bit	2,a
	jp	z,CLOSE_END

	;--- Comprueba si se esta pulsando F1/F2/F3

	ld	a,(#FBEB)	;#FBEB contiene el estado de
	and	%11100000	;F1, F2 y F3 en los bits
	cp	%11100000	;5, 6 y 7 respectivamente
	jp	z,NO_F_KEY	;(0 si estan pulsadas)

	;--- F1? Imprimir ayuda

CHECK_F1:	bit	5,a
	jr	nz,CHECK_F2

	print	HELP_S
	jr	END_F_KEY

	;--- F2? Cambiar modo caracter/linea

CHECK_F2:	bit	6,a
	jr	nz,CHECK_F3

	ld	a,(INPUT_MODE)
	cpl
	ld	(INPUT_MODE),a

	ld	de,INPTOG0_S
	ld	hl,LINE_S
	or	a
	jr	z,CHECK_F22
	ld	de,INPTOG1_S
	ld	hl,CHAR_S
CHECK_F22:	push	hl	;Imprime informacion sobre el cambio
	ld	c,_STROUT	;y actualiza el texto de ayuda
	call	DOS
	pop	hl
	ld	de,LINCHAR_S
	ld	bc,9
	ldir
	jr	END_F_KEY

	;--- F3? Cambiar eco local ON/OFF

FUN_XOR:	equ	1 xor 8	;_CONIN xor _INNOE

CHECK_F3:	ld	a,(GETCHAR_FUN)
	xor	FUN_XOR	;Cambia _CONIN <--> _INNOE
	ld	(GETCHAR_FUN),a	;(la funcion DOS usada para obtener un caracter)

	cp	_CONIN
	ld	de,ECHOTOG0_S
	ld	hl,ON_S
	jr	z,CHECK_F32
	ld	de,ECHOTOG1_S
	ld	hl,OFF_S
CHECK_F32:	push	hl	;Muestra informacion sobre el cambio
	ld	c,_STROUT	;y actualiza el texto de ayuda
	call	DOS
	pop	hl
	ld	de,ECHONOFF_S
	ld	bc,3
	ldir

END_F_KEY:	ld	c,_DIRIO	;Borra el buffer del teclado
	ld	e,#FF	;para evitar que el contenido de la tecla Fx
	call	DOS	;sea aceptado como datos a enviar
	or	a
	jr	nz,END_F_KEY

	jp	END_KEY

NO_F_KEY:	;

	;--- Comprueba si se han pulsado otras teclas, en ese caso,
	;    se supone que son datos para enviar a la conexion TCP
	;    (se lee una linea entera o solo un caracter, dependiendo
	;    del modo de entrada actual)

	ld	c,_CONST	;Se ha pulsado alguna tecla?
	call	DOS
	or	a
	jp	z,END_KEY

	ld	a,(INPUT_MODE)
	or	a
	jr	nz,GET_INPUT_C

	;* Modo linea: obtiene una linea, anyade LF al final,
	;  y la envia

GET_INPUT_L:	ld	a,255
	ld	(BUFFER),a
	ld	c,_BUFIN	;Lee caracteres hasta que se pulsa ENTER
	ld	de,BUFFER
	call	DOS
	call	LF	;Imprime LF para cambiar de linea en pantalla

	ld	a,(BUFFER+1)	;Aqade LF al final de la linea
	ld	c,a
	ld	b,0
	inc	bc
	ld	hl,BUFFER+2
	add	hl,bc
	ld	(hl),10
	inc	bc

	ld	a,(CON_NUM)	;Envia la linea a la conexion
	ld	hl,BUFFER+2
	scf		;Especifica "Push"
	inl	TCP_SEND
	jp	c,TCP_ERROR

	jr	END_KEY

	;* Modo caracter: lee el caracter con o sin eco,
	;  y lo envia a la conexion

GET_INPUT_C:	ld	a,(GETCHAR_FUN)
	ld	c,a
	push	bc
	call	DOS
	ld	(BUFFER),a

	pop	hl	;Si el caracter is CR, envia tambien LF
	cp	13
	ld	bc,1
	jr	nz,GET_INPUT_C2

	ld	a,10
	ld	(BUFFER+1),a
	ld	a,l	;Si el eco local esta activado, el LF
	cp	_CONIN	;tiene que ser mostrado explicitamente
	call	z,LF
	ld	bc,2

GET_INPUT_C2:	ld	a,(CON_NUM)	;Envia el o los caractere(s)
	ld	hl,BUFFER
	scf		;Especifica "PUSH"
	inl	TCP_SEND
	jp	c,TCP_ERROR

END_KEY:	;

	;--- Fin de un paso del bucle principal:
	;    Damos al codigo de INL una oportunidad de ejecutarse
	;    y repetimos el bucle

	inl	WAIT_INT
	jp	MAIN_LOOP


	;--- Se salta aqui si una llamada a TCP_SEND o TCP_RCV
	;    devuelve un error.
	;    Entrada: A=Codigo de error

	;* Si el error es "Bufer de salida lleno",
	;  imprime el error, cierra la conexion y termina

TCP_ERROR:	cp	4
	jr	nz,TCP_ERROR2

	ld	a,(CON_NUM)
	inl	TCP_CLOSE
	print	BUFOVF_S
	jp	TERMINATE
TCP_ERROR2:

	;* En caso contrario el error solo puede ser "conexion cerrada"
	;  (no puede ser "Estado invalido para enviar datos", ya que
	;  la conexion estara en estado CLOSED, ESTABLISHED o CLOSE-WAIT;
	;  y suponemos que no es "Identificador de conexion invalido");
	;  imprime la causa y termina

	print	TWO_NL_S
	ld	a,(CON_NUM)
	inl	TCP_STATUS
	ld	de,TCPCLOSED_T
	call	GET_STRING
	ld	c,_STROUT
	call	DOS
	jp	TERMINATE


;******************************
;***                        ***
;***   RUTINAS AUXILIARES   ***
;***                        ***
;******************************

;--- NOMBRE: COMP
;      Comparacion de HL con DE (16 bits sin signo)
;    ENTRADA:   HL, DE = numeros a comparar
;    SALIDA:     C, NZ si HL > DE
;                C,  Z si HL = DE
;               NC, NZ si HL < DE
;    REGISTROS: -

COMP:	call	_COMP
	ccf
	ret

_COMP:	ld	a,h
	sub	d
	ret	nz
	ld	a,l
	sub	e
	ret


;--- NOMBRE: EXTPAR
;      Extraccion de un parametro de la linea de comandos
;    ENTRADA:   A  = Parametro a extraer (el primero es el 1)
;               DE = Bufer para dejar el parametro
;    SALIDA:    A  = Numero de parametros
;               CY = 1 -> No existe ese parametro
;                         B indefinido, bufer inalterado
;               CY = 0 -> B = Longitud del parametro (no incluye el 0)
;                         Parametro a partir de DE, acabado en 0
;    REGISTROS: -
;    LLAMADAS:  -

EXTPAR:	or	a	;Volvemos con error si A = 0
	scf
	ret	z

	ld	b,a
	ld	a,(#80)	;Volvemos con error si no hay parametros
	or	a
	scf
	ret	z
	ld	a,b

	push	af,hl
	ld	a,(#80)
	ld	c,a	;Ponemos un 0 al final
	ld	b,0	;(necesario en DOS 1)
	ld	hl,#81
	add	hl,bc
	ld	(hl),0
	pop	hl,af

	push	hl,de,ix
	ld	ix,0	;IXl: Numero de parametros    
	ld	ixh,a	;IXh: Parametro a extraer    
	ld	hl,#81

PASASPC:	ld	a,(hl)	;Vamos pasando espacios    
	or	a
	jr	z,ENDPNUM
	cp	" "
	inc	hl
	jr	z,PASASPC

	inc	ix
PASAPAR:	ld	a,(hl)	;Vamos pasando el parametro    
	or	a
	jr	z,ENDPNUM
	cp	" "
	inc	hl
	jr	z,PASASPC
	jr	PASAPAR

ENDPNUM:	ld	a,ixh	;Error si se el parametro a extraer    
	dec	a	;(anyadido para quitar el jrmy)
	cp	ixl	;es mayor que el numero de parametros    
	jr	nc,EXTPERR
	;jrmy   EXTPERR          ;existentes    

	ld	hl,#81
	ld	b,1	;B = parametro actual    
PASAP2:	ld	a,(hl)	;Pasamos espacios hasta dar    
	cp	" "	;con el siguiente parametro    
	inc	hl
	jr	z,PASAP2

	ld	a,ixh	;Si es el que buscamos lo extraemos.    
	cp	B	;Si no ...    
	jr	z,PUTINDE0

	inc	B
PASAP3:	ld	a,(hl)	;... lo pasamos y volvemos a PAPAP2    
	cp	" "
	inc	hl
	jr	nz,PASAP3
	jr	PASAP2

PUTINDE0:	ld	b,0
	dec	hl
PUTINDE:	inc	b
	ld	a,(hl)
	cp	" "
	jr	z,ENDPUT
	or	a
	jr	z,ENDPUT
	ld	(de),a	;Ponemos el parametro a partir de (DE)    
	inc	de
	inc	hl
	jr	PUTINDE

ENDPUT:	xor	a
	ld	(de),a
	dec	b

	ld	a,ixl
	or	a
	jr	FINEXTP
EXTPERR:	scf
FINEXTP:	pop	ix,de,hl
	ret


;--- Terminacion por la pulsacion de ESC o CTRL-C
;    Se cierra la conexion, o se aborta si se esta pulsado CTRL,
;    y el programa termina

CLOSE_END:	ld	a,(CON_NUM)
	cp	#FF
	jr	z,TERMINATE

	ld	a,(#FBEB)	;Comprueba el estado de la tecla CTRL
	bit	1,a	;para decidir si ejecutar
	ld	ix,TCP_CLOSE	;CLOSE o ABORT
	ld	de,USERCLOS_S	;(siempre ABORT en case de CTRL-C)
	jr	nz,CLOSE_END2	;y que mensaje mostrar
	ld	ix,TCP_ABORT	;("el usuario ha cerrado" o
	ld	de,USERAB_S	;"el usuario ha abortado")
CLOSE_END2:	push	de
	ld	a,(CON_NUM)
	ld	hl,CLOSE_END3
	push	hl

	jp	(ix)
CLOSE_END3:	pop	de
	ld	c,_STROUT
	call	DOS
	jr	TERMINATE


;--- Terminaciones del programa

	;* Parametro invalido

INVPAR:	print	INVPAR_S
	jp	TERMINATE

	;* Falta el parametro

MISSPAR:	print	MISSPAR_S
	jp	TERMINATE

	;* Rutina generica de terminacion

TERMINATE:
	ld	a,2	;Restaura TPA en pagina 1
	call	PUT_P1

	ld	a,(DOS2)	;Bajo DOS 2, cancela la rutina
	or	a	;de control de CTRL-C
	ld	de,0
	ld	c,_DEFAB
	call	nz,DOS

	ld	c,_TERM0
	jp	DOS


;--- Imprime LF

LF:	ld	e,10
	ld	c,_CONOUT
	jp	DOS


;--- Rutina de conexion de un segmento en pagina 1, se obtiene
;    desde la zona de trabajo de INl en pagina 3 
;    y asi no hay que preocuparse de si estamos en DOS 1 o en DOS 2


PUT_P1:	ds	3


;--- NOMBRE: NUMTOASC
;      Conversion de un entero de 16 bits a una cadena de caracteres
;    ENTRADA:    DE = Numero a convertir
;                HL = Buffer para depositar la cadena
;                B  = Numero total de caracteres de la cadena
;                     sin incluir signos de terminacion
;                C  = Caracter de relleno
;                     El numero se justifica a la derecha, y los
;                     espacios sobrantes se rellenan con el caracter (C).
;                     Si el numero resultante ocupa mas caracteres que
;                     los indicados en B, este registro es ignorado
;                     y la cadena ocupa los caracteres necesarios.
;                     No se cuenta el caracter de terminacion, "$" o 00,
;                     a efectos de longitud.
;                 A = &B ZPRFFTTT
;                     TTT = Formato del numero resultante
;                            0: decimal
;                            1: hexdecimal
;                            2: hexadecimal, comenzando con "&H"
;                            3: hexadecimal, comenzando con "#"
;                            4: hexadecimal, acabado en "H"
;                            5: binario
;                            6: binario, comenzando con "&B"
;                            7: binario, acabado en "B"
;                     R   = Rango del numero
;                            0: 0..65535 (entero sin signo)
;                            1: -32768..32767 (entero en complemento a dos)
;                               Si el formato de salida es binario,
;                               el numero se interpreta como entero de 8 bits
;                               y el rango es 0..255. Es decir, el bit R
;                               y el registro D son ignorados.
;                     FF  = Tipo de finalizacion de la cadena
;                            0: Sin finalizacion especial
;                            1: Adicion de un caracter "$"
;                            2: Adicion de un caracter 00
;                            3: Puesta a 1 del 7o bit del ultimo caracter
;                     P   = Signo "+"
;                            0: No agnadir un signo "+" a los numeros positivos
;                            1: Agnadir un signo "+" a los numeros positivos
;                     Z   = Ceros sobrantes
;                            0: Quitar ceros a la izquierda
;                            1: No quitar ceros a la izquierda
;    SALIDA:    Cadena a partir de (HL)
;               B = Numero de caracteres de la cadena que forman
;                   el numero, incluyendo el signo y el indicador
;                   de tipo si son generados
;               C = Numero de caracteres totales de la cadena
;                   sin contar el "$" o el 00 si son generados
;    REGISTROS: -

NUMTOASC:	push	af,ix,de,hl
	ld	ix,WorkNTOA
	push	af,af
	and	%00000111
	ld	(ix+0),a	;Tipo 
	pop	af
	and	%00011000
	rrca
	rrca
	rrca
	ld	(ix+1),a	;Fin 
	pop	af
	and	%11100000
	rlca
	rlca
	rlca
	ld	(ix+6),a	;Banderas: Z(cero), P(signo +), R(rango) 
	ld	(ix+2),b	;No. caracteres finales 
	ld	(ix+3),c	;Caracter de relleno 
	xor	a
	ld	(ix+4),a	;Longitud total 
	ld	(ix+5),a	;Longitud del numero 
	ld	a,10
	ld	(ix+7),a	;Divisor a 10 
	ld	(ix+13),l	;Buffer pasado por el usuario 
	ld	(ix+14),h
	ld	hl,BufNTOA
	ld	(ix+10),l	;Buffer de la rutina 
	ld	(ix+11),h

ChkTipo:	ld	a,(ix+0)	;Divisor a 2 o a 16, o dejar a 10 
	or	a
	jr	z,ChkBoH
	cp	5
	jp	nc,EsBin
EsHexa:	ld	a,16
	jr	GTipo
EsBin:	ld	a,2
	ld	d,0
	res	0,(ix+6)	;Si es binario esta entre 0 y 255 
GTipo:	ld	(ix+7),a

ChkBoH:	ld	a,(ix+0)	;Comprueba si hay que poner "H" o "B" 
	cp	7	;al final 
	jp	z,PonB
	cp	4
	jr	nz,ChkTip2
PonH:	ld	a,"H"
	jr	PonHoB
PonB:	ld	a,"B"
PonHoB:	ld	(hl),a
	inc	hl
	inc	(ix+4)
	inc	(ix+5)

ChkTip2:	ld	a,d	;Si el numero es 0 nunca se pone signo 
	or	e
	jr	z,NoSgn
	bit	0,(ix+6)	;Comprueba rango   
	jr	z,SgnPos
ChkSgn:	bit	7,d
	jr	z,SgnPos
SgnNeg:	push	hl	;Niega el numero 
	ld	hl,0	;Signo=0:sin signo; 1:+; 2:-   
	xor	a
	sbc	hl,de
	ex	de,hl
	pop	hl
	ld	a,2
	jr	FinSgn
SgnPos:	bit	1,(ix+6)
	jr	z,NoSgn
	ld	a,1
	jr	FinSgn
NoSgn:	xor	a
FinSgn:	ld	(ix+12),a

ChkDoH:	ld	b,4
	xor	a
	cp	(ix+0)
	jp	z,EsDec
	ld	a,4
	cp	(ix+0)
	jp	nc,EsHexa2
EsBin2:	ld	b,8
	jr	EsHexa2
EsDec:	ld	b,5

EsHexa2:	push	de
Divide:	push	bc,hl	;DE/(IX+7)=DE, resto A 
	ld	a,d
	ld	c,e
	ld	d,0
	ld	e,(ix+7)
	ld	hl,0
	ld	b,16
BucDiv:	rl	c
	rla
	adc	hl,hl
	sbc	hl,de
	jr	nc,$+3
	add	hl,de
	ccf
	djnz	BucDiv
	rl	c
	rla
	ld	d,a
	ld	e,c
	ld	a,l
	pop	hl,bc

ChkRest9:	cp	10	;Convierte el resto en caracter 
	jp	nc,EsMay9
EsMen9:	add	a,"0"
	jr	PonEnBuf
EsMay9:	sub	10
	add	a,"A"

PonEnBuf:	ld	(hl),a	;Pone caracter en buffer 
	inc	hl
	inc	(ix+4)
	inc	(ix+5)
	djnz	Divide
	pop	de

ChkECros:	bit	2,(ix+6)	;Comprueba si hay que eliminar ceros 
	jr	nz,ChkAmp
	dec	hl
	ld	b,(ix+5)
	dec	b	;B=no. de digitos a comprobar 
Chk1Cro:	ld	a,(hl)
	cp	"0"
	jr	nz,FinECeros
	dec	hl
	dec	(ix+4)
	dec	(ix+5)
	djnz	Chk1Cro
FinECeros:	inc	hl

ChkAmp:	ld	a,(ix+0)	;Coloca "#", "&H" o "&B" si es necesario 
	cp	2
	jr	z,PonAmpH
	cp	3
	jr	z,PonAlm
	cp	6
	jr	nz,PonSgn
PonAmpB:	ld	a,"B"
	jr	PonAmpHB
PonAlm:	ld	a,"#"
	ld	(hl),a
	inc	hl
	inc	(ix+4)
	inc	(ix+5)
	jr	PonSgn
PonAmpH:	ld	a,"H"
PonAmpHB:	ld	(hl),a
	inc	hl
	ld	a,"&"
	ld	(hl),a
	inc	hl
	inc	(ix+4)
	inc	(ix+4)
	inc	(ix+5)
	inc	(ix+5)

PonSgn:	ld	a,(ix+12)	;Coloca el signo 
	or	a
	jr	z,ChkLon
SgnTipo:	cp	1
	jr	nz,PonNeg
PonPos:	ld	a,"+"
	jr	PonPoN
	jr	ChkLon
PonNeg:	ld	a,"-"
PonPoN	ld	(hl),a
	inc	hl
	inc	(ix+4)
	inc	(ix+5)

ChkLon:	ld	a,(ix+2)	;Pone caracteres de relleno si necesario 
	cp	(ix+4)
	jp	c,Invert
	jr	z,Invert
PonCars:	sub	(ix+4)
	ld	b,a
	ld	a,(ix+3)
Pon1Car:	ld	(hl),a
	inc	hl
	inc	(ix+4)
	djnz	Pon1Car

Invert:	ld	l,(ix+10)
	ld	h,(ix+11)
	xor	a	;Invierte la cadena 
	push	hl
	ld	(ix+8),a
	ld	a,(ix+4)
	dec	a
	ld	e,a
	ld	d,0
	add	hl,de
	ex	de,hl
	pop	hl	;HL=buffer inicial, DE=buffer final 
	ld	a,(ix+4)
	srl	a
	ld	b,a
BucInv:	push	bc
	ld	a,(de)
	ld	b,(hl)
	ex	de,hl
	ld	(de),a
	ld	(hl),b
	ex	de,hl
	inc	hl
	dec	de
	pop	bc
	ld	a,b
	or	a
	jr	z,ToBufUs
	djnz	BucInv
ToBufUs:	ld	l,(ix+10)
	ld	h,(ix+11)
	ld	e,(ix+13)
	ld	d,(ix+14)
	ld	c,(ix+4)
	ld	b,0
	ldir
	ex	de,hl

ChkFin1:	ld	a,(ix+1)	;Comprueba si ha de acabar en "$" o en 0  
	and	%00000111
	or	a
	jr	z,Fin
	cp	1
	jr	z,PonDolar
	cp	2
	jr	z,PonChr0

PonBit7:	dec	hl
	ld	a,(hl)
	or	%10000000
	ld	(hl),a
	jr	Fin

PonChr0:	xor	a
	jr	PonDo0
PonDolar:	ld	a,"$"
PonDo0:	ld	(hl),a
	inc	(ix+4)

Fin:	ld	b,(ix+5)
	ld	c,(ix+4)
	pop	hl,de,ix,af
	ret

WorkNTOA:	defs	16
BufNTOA:	ds	10


;--- EXTNUM16
;      Extrae un numero de 16 bits desde una cadena ASCII acabada en 0
;    Entrada: HL = Direccion de la cadena ASCII
;    Salida:  BC = Numero extraido
;             Cy = 1 si hay error (cadena invalida)

EXTNUM16:	call	EXTNUM
	ret	c
	jp	c,INVPAR	;Error si es >65535

	ld	a,e
	or	a	;Error si el ultimo caracter no es 0
	ret	z
	scf
	ret


;--- NOMBRE: EXTNUM
;      Extraccion de un numero de 5 digitos almacenado en formato ASCII
;    ENTRADA:    HL = Dir. de comienzo de la cadena ASCII
;    SALIDA:     CY-BC = numero de 17 bits
;                D  = numero de digitos que forman el numero
;                     El numero se considera extraido
;                     al encontrar un caracter no numerico,
;                     o cuando se han extraido cinco digitos.
;                E  = primer caracter incorrecto (o sexto digito)
;                A  = error:
;                     0 => Sin error
;                     1 => El numero tiene mas de 5 digitos.
;                          CY-BC contiene entonces el numero formado por
;                          los cinco primeros digitos
;    REGISTROS:  -
;    LLAMADAS:   -
;    VARIABLES:  -

EXTNUM:	push	hl,ix
	ld	ix,ACA
	res	0,(ix)
	set	1,(ix)
	ld	bc,0
	ld	de,0
BUSNUM:	ld	a,(hl)	;Salta a FINEXT si el caracter no es 
	ld	e,a	;IXh = ultimo caracter leido por ahora 
	cp	"0"	;un numero, o si es el sexto caracter 
	jr	c,FINEXT
	cp	"9"+1
	jr	nc,FINEXT
	ld	a,d
	cp	5
	jr	z,FINEXT
	call	POR10

SUMA:	push	hl	;BC = BC + A 
	push	bc
	pop	hl
	ld	bc,0
	ld	a,e
	sub	"0"
	ld	c,a
	add	hl,bc
	call	c,BIT17
	push	hl
	pop	bc
	pop	hl

	inc	d
	inc	hl
	jr	BUSNUM

BIT17:	set	0,(ix)
	ret
ACA:	db	0	;b0: num>65535. b1: mas de 5 digitos 

FINEXT:	ld	a,e
	cp	"0"
	call	c,NODESB
	cp	"9"+1
	call	nc,NODESB
	ld	a,(ix)
	pop	ix,hl
	srl	a
	ret

NODESB:	res	1,(ix)
	ret

POR10:	push	de,hl	;BC = BC * 10 
	push	bc
	push	bc
	pop	hl
	pop	de
	ld	b,3
ROTA:	sla	l
	rl	h
	djnz	ROTA
	call	c,BIT17
	add	hl,de
	call	c,BIT17
	add	hl,de
	call	c,BIT17
	push	hl
	pop	bc
	pop	hl,de
	ret


;--- CHECK_KEY: Llama a una rutina del DOS para que se pueda
;    detectar la pulsacion de CTRL-C y asi dar oportunidad
;    al usuario de abortar el programa.
;    De paso, devuelve A<>0 si se ha pulsado una tecla.

CHECK_KEY:	ld	e,#FF
	ld	c,_DIRIO
	jp	DOS


;--- BYTE2ASC: Conversion del numero A en una cadena sin terminacion
;    Deposita la cadena en (IX), y modifica IX para que apunte tras la cadena
;    Modifica: C

BYTE2ASC:	cp	10
	jr	c,B2A_1D
	cp	100
	jr	c,B2A_2D
	cp	200
	jr	c,B2A_1XX
	jr	B2A_2XX

	;--- Un digito

B2A_1D:	add	"0"
	ld	(ix),a
	inc	ix
	ret

	;--- Dos digitos

B2A_2D:	ld	c,"0"
B2A_2D2:	inc	c
	sub	10
	cp	10
	jr	nc,B2A_2D2

	ld	(ix),c
	inc	ix
	jr	B2A_1D

	;--- Entre 100 y 199

B2A_1XX:	ld	(ix),"1"
	sub	100
B2A_XXX:	inc	ix
	cp	10
	jr	nc,B2A_2D	;Si es 1XY con X>0
	ld	(ix),"0"	;Si es 10Y
	inc	ix
	jr	B2A_1D

	;--- Entre 200 y 255

B2A_2XX:	ld	(ix),"2"
	sub	200
	jr	B2A_XXX


;--- GET_STRING: Devuelve una cadena asociada a un numero, o "Unknown".
;    Entrada: DE = Puntero a la tabla de cadenas y numeros, con el formato:
;                  db num,"Cadena$"
;                  db num2,"Cadena2$"
;                  ...
;                  db 0
;             B = Numero asociado
;    Salida:  DE = Puntero a la cadena

GET_STRING:	ld	a,(de)
	inc	de
	or	a	;No encontramos el codigo: mostramos "Unknown"
	jr	nz,LOOP_GETS2
	ld	de,STRUNK_S
	ret

LOOP_GETS2:	cp	b	;Coincide?
	ret	z

LOOP_GETS3:	ld	a,(de)	;No: pasa al siguiente
	inc	de
	cp	"$"
	jr	nz,LOOP_GETS3
	jr	GET_STRING

STRUNK_S:	db	"Unknown$"


;****************************
;***                      ***
;***   DATOS, VARIABLES   ***
;***                      ***
;****************************

;--- Areas de INL

INL_SEG1:	db	0
;INL_SEG2:       db      0      ;--- No necesarios
;INL_P3DIR:      dw      0      ;--- en este programa

;--- Datos de la conexion, se rellena con los parametros
;    de la linea de comandos

IP_REMOTE:	db	0,0,0,0
PORT_REMOTE:	dw	0
PORT_LOCAL:	dw	#FFFF	;Puerto aleatorio si no se especifica uno
PASSIVE_OPEN:	db	0

;--- Variables

CON_NUM:	db	#FF	;Numero de conexion
INPUT_MODE:	db	0	;0 para modo linea, #FF para modo caracter
GETCHAR_FUN:	db	_CONIN	;_CONIN para eco ON, _INNOE para eco OFF
DOS2:	db	0	;0 para DOS 1, #FF para DOS 2

;--- Cadenas de texto

PRESENT_S:
	db	"TCP Console (simplified Telnet client) for InterNestor Lite 1.03",13,10
	db	"By Konami Man, 4-2005",13,10,10,"$"

INFO_S:	db	"Usage: TCPCON <host name>|<remote IP address> <remote port> [<local port>] [P]",13,10,10
	db	"       <host name> can be 0.0.0.0 to accept a connection from any host",13,10
	db	"                   (only for passive connections)",13,10
	db	"       <local port>: if not specified, a random port will be selected",13,10
	db	"       P: Use passive connection open",13,10,"$"

NOINS_S:	db	"*** InterNestor Lite is not installed",13,10,"$"
INVPAR_S:	db	"*** Invalid parameter(s)",13,10,"$"
MISSPAR_S:	db	"*** Missing parameter(s)",13,10,"$"
BUFOVF_S:	db	"*** Output buffer overflow",13,10,"$"
ERROR_S:	db	"*** ERROR: $"
OPENING_S:	db	"Opening connection (press ESC to cancel)... $"
RESOLVING_S:	db	"Resolving host name... $"
OPENED_S:	db	"OK!",13,10,10
	db	"*** Press F1 for help",13,10,10,"$"
HELP_S:	db	13,10,"*** F1: Show this help",13,10
	db	"*** F2: Toggle line/character mode",13,10
	db	"        Current mode is: "
LINCHAR_S:	db	"line     ",13,10
	db	"*** F3: Toggle local echo ON/OFF (only on character mode)",13,10
	db	"        Currently local echo is: "
ECHONOFF_S:	db	"ON ",13,10
	db	"*** ESC: Close connection and exit",13,10
	db	"*** CTRL+ESC: Abort connection and exit",13,10
	db	"*** Type the text to be sent to the other side.",13,10
	db	"    In line mode, the line text will be sent when pressing ENTER.",13,10
	db	"    In character mode, each typed character will be sent immediately.",13,10
	db	"    Incoming data will be printed out to the screen.",13,10,10,"$"
INPTOG0_S:	db	13,10,"*** Input mode toggled to line mode",13,10,"$"
INPTOG1_S:	db	13,10,"*** Input mode toggled to character mode",13,10,"$"
ECHOTOG0_S:	db	13,10,"*** Local echo toggled ON",13,10,"$"
ECHOTOG1_S:	db	13,10,"*** Local echo toggled OFF",13,10,"$"
USERCLOS_S:	db	13,10,"*** Connection closed by user",13,10,"$"
USERAB_S:	db	13,10,"*** Connection aborted by user",13,10,"$"
LINE_S:	db	"line     "
CHAR_S:	db	"character"
ON_S:	db	"ON "
OFF_S:	db	"OFF"
ASTERISK_S:	db	"*** $"

	;* Resolucion del nombre del host

RESOLVERR_S:	db	13,10,"ERROR "
RESOLVERRC_S:	ds	6	;Deja espacio para "<codigo>: $"
RESOLVOK_S:	db	"OK: "
RESOLVIP_S:	ds	16	;Espacio para "xxx.xxx.xxx.xxx$"
TWO_NL_S:	db	13,10
ONE_NL_S:	db	13,10,"$"

	;* Errores de DNS_Q

DNSQERRS_T:	db	1,"Not connected to Internet$"
	db	4,"No DNS servers available$"
	db	0

	;* Errores de DNS_S

DNSRERRS_T:	db	1,"Query format error$"
	db	2,"Server failure$"
	db	3,"Name error (this host name does not exist)$"
	db	4,"Query type not implemented by the server$"
	db	5,"Query refused by the server$"
	db	6,"DNS error 6$"
	db	7,"DNS error 7$"
	db	8,"DNS error 8$"
	db	9,"DNS error 9$"
	db	10,"DNS error 10$"
	db	11,"DNS error 11$"
	db	12,"DNS error 12$"
	db	13,"DNS error 13$"
	db	14,"DNS error 14$"
	db	15,"DNS error 15$"
	db	16,"Server(s) not responding to queries$"
	db	17,"Total operation timeout expired$"
	db	19,"Internet connection lost$"
	db	20,"Dead-end reply (not containing answers nor redirections)$"
	db	21,"Answer is truncated$"
	db	0

	;* Errores de TCP_OPEN

TCPOPERRS_T:	db	1,"Too many TCP connections opened$"
NOCON_S:	db	2,"Not connected to Internet$"
	db	3,"Connection already exists, try another local port number$"
		db	4,"Unespecified remote socket is not allowed on active connections$"
		db	5,"Invalid user timeout value$"	;Should never occur
		db	0

	;* Razones de cierre TCP

TCPCLOSED_T:
PEERCLOSE_S:	db	1,"*** Connection closed by peer$"	;En realidad cierre local, pero solo cerramos cuando el host cierra
	db	2,"*** Connection locally aborted$"
	db	3,"*** Connection refused (RST received)$"
	db	4,"*** Data sending timeout expired$"
	db	5,"*** Connection timeout expired$"
	db	6,"*** Internet connection lost$"
	db	7,"*** Destination host is unreachable$"
	db	0

;--- Bufer para el nombre del host remoto

HOST_NAME:	;

;--- Bufer temporal generico para enviar y recibir datos
;    y para extraer los parametros de la linea de comandos

BUFFER:	equ	HOST_NAME+256
