	;--- Servidor/cliente de TFTP para InterNestor Lite 1.02
	;    Por Konami Man, 12-2004

	;Caracteristicas generales:

	;- Conforme a RFC1350, excepto por lo indicado mas abajo.
	;- No soporta opciones TFTP
	;  (lo cual implica: tamanyo de bloque fijado en 512 bytes).
	;- Solo soporta el modo binario de transmision ("OCTET").
	;- No se envian mensajes de error en caso de recibir
	;  paquetes invalidos o inesperados. Solo se envian
	;  en caso de timeout, error de disco o fichero no encontrado.
	;- No se capturan los errores de disco en DOS 2.
	;- El numero maximo de retransmisiones para un paquete
	;  antes de cancelar la transmision y el intervalo entre
	;  retransmisiones son fijos. Se definen en las constantes
	;  RETX_CNT_MAX y RETX_TIMER_MAX, respectivamente.


	.label	20	;Directiva para Compass

;*****************************
;***                       ***
;***  MACROS Y CONSTANTES  ***
;***                       ***
;*****************************

	;--- Constantes varias

RETX_TIMER_MAX:	equ	3	;Segundos entre retransmisiones
RETX_CNT_MAX:	equ	5	;Numero maximo de retransmisiones

MAXFILES:	equ	1	;Max. ficheros abribles(?!) en DOS 1

ENYEMAY:	equ	165	;ASCII de enye mayuscula
ENYEMIN:	equ	164	;ASCII de enye minuscula

TIME:	equ	#FC9E	;Temporizador del sistema, 50/60Hz

	;--- Macro para imprimir una cadena

print:	macro	@s
	ld	de,@s
	ld	c,_STROUT
	call	5
	endm

	;--- Macro para llamar a una funcion de InterNestor Lite.
	;
	;    Bajo DOS 1, tras una llamada a cualquier funcion del DOS
	;    el sistema restaura el segmento de TPA en la pagina 1,
	;    cosa que no ocurre bajo DOS 2.
	;
	;    Usando esta macro nos aseguramos de que las llamadas
	;    a INL siempre se efectuan correctamente.

inl:	macro	@d
	push	af
	ld	a,(INL_SEG1)
	call	PUT_P1
	pop	af

	call	@d
	endm

	;--- Funciones del DOS

	;* DOS 1

_TERM0:	equ	#00
_CONOUT:	equ	#02
_DIRIO:	equ	#06
_STROUT:	equ	#09
_FOPEN:	equ	#0F
_FCLOSE:	equ	#10
_SFIRST:	equ	#11
_SNEXT:	equ	#12
_FMAKE:	equ	#16
_SETDTA:	equ	#1A
_WRBLK:	equ	#26
_RDBLK:	equ	#27

	;* DOS 2

_FFIRST:	equ	#40
_FNEXT:	equ	#41
_OPEN:	equ	#43
_CREATE:	equ	#44
_CLOSE:	equ	#45
_READ:	equ	#48
_WRITE:	equ	#49
_PARSE:	equ	#5B
_DEFAB:	equ	#63
_EXPLAIN:	equ	#66
_DOSVER:	equ	#6F

	;--- Variables y rutinas de InterNestor Lite

IP_STRING:	equ	#4036	;Convierte una IP en una cadena
DNS_Q:	equ	#405D	;Efectua peticion DNS
DNS_R:	equ	#4060	;Obtiene respuesta DNS
UDP_SEND:	equ	#4057	;Envia un paquete UDP
UDP_RCV:	equ	#405A	;Recibe un paquete UDP
WAIT_INT:	equ	#4081	;Espera a la siguiente interrupcion del reloj
NETWORK_STATE:	equ	#4084	;Comprueba el estado de la red


;****************************
;***                      ***
;***  PROGRAMA PRINCIPAL  ***
;***                      ***
;****************************

	org	#100

	;------------------------------
	;---  Inicializacion comun  ---
	;------------------------------

	;--- Imprime presentacion

	print	PRESENT_S

	;--- Comprueba si hay parametros,
	;    si no los hay, muestra informacion y termina

	ld	a,1
	ld	de,PARAM_BUFFER
	call	EXTPAR
	jr	nc,HAYPARS

TERMINFO:	print	INFO_S
	jp	TERMIN2
HAYPARS:	;

	;--- Comprueba version del DOS y establece DOS2

	ld	c,_DOSVER
	call	5
	or	a
	jr	nz,NODOS2
	ld	a,b
	cp	2
	jr	c,NODOS2

	ld	a,#FF
	ld	(DOS2),a	;#FF para DOS 2, 0 para DOS 1
NODOS2:	;

	;--- Comprueba que InterNestor Lite este instalado, si no
	;    muestra un error y termina

	xor	a
	ld	de,#2203
	call	#FFCA
	or	a
	jr	nz,OKINS

	print	NOINS_S
	jp	TERMIN2
OKINS:	;

	ld	a,b
	ld	(INL_SEG1),a
	;ld      a,c                    ;--- En este programa no necesitamos
	;ld      (INL_SEG2),a           ;--- esta informacion, nos basta
	;ld      (INL_P3DIR),hl         ;--- el numero del segmento de codigo

	;--- Obtiene PUT_P1 a partir
	;    de la zona de trabajo de INL en pagina 3
	;    (tiene offset 15)

	ld	bc,15
	add	hl,bc
	ld	de,PUT_P1
	ld	bc,3
	ldir

	;> Lo siguiente no hara nada en DOS 1
	ld	de,TERM_AB	;Rutina a ejecutar
	ld	c,_DEFAB	;si se pulsa CTRL-C/STOP
	call	5	;o se ABORTa un error de disco

	;--- Inicializa zona de FCBs (solo es necesario en DOS 1)

	xor	a
	ld	(FCBS),a

	;--- Conecta el segmento de InterNestor Lite en pagina 1
	;    (No es necesario porque usamos la macro "inl")

	;ld     a,(INL_SEG1)
	;call   PUT_P1

	;--- Comprueba que realmente estemos conectados,
	;    en caso contrario muestra error y termina

	inl	NETWORK_STATE	;La red esta disponible?
	cp	2
	jr	z,CONNECT_OK

	print	NOCON_S
	jp	TERMINATE
CONNECT_OK:	;

        ;--- Elimina los paquetes UDP espureos que haya pendientes

CLEAR_UDP:      ld      hl,0
        inl     UDP_RCV
        jr      nc,CLEAR_UDP

	;--- Comprueba si el primer parametro es /S...,
	;    en ese caso salta al modo servidor

	ld	a,(PARAM_BUFFER)
	cp	"/"
	jp	nz,NO_SERVER
	ld	a,(PARAM_BUFFER+1)
	or	#20
	cp	"s"
	jp	z,TO_SERVER

	jp	INVPAR	;Si es "/<algo>" con <algo><>S

	print	INVPAR_S
	jp	TERMINATE
NO_SERVER:	;


	;--------------------------------------------
	;---  Inicializacion comun, modo cliente  ---
	;--------------------------------------------

	;--- Obtiene el segundo parametro y decide
	;    si hay que enviar o recibir (establece variable GETPUT)

	ld	de,PARAM_BUFFER
	ld	a,2
	call	EXTPAR
	jp	c,MISSPAR	;No hay segundo parametro?

	ld	a,(PARAM_BUFFER)
	or	#20
	cp	"g"
	jr	z,GETPUT_OK
	cp	"r"
	jr	z,GETPUT_OK	;"G" o "R": Recibir

	ld	b,a
	ld	a,#FF
	ld	(GETPUT),a
	ld	a,b
	cp	"p"
	jr	z,GETPUT_OK
	cp	"s"	;"P" o "S": Enviar
	jp	nz,INVPAR	;Otro: Error
GETPUT_OK:	;

	;--- Resuelve el nombre del servidor

	ld	a,1
	ld	de,PARAM_BUFFER
	call	EXTPAR

	print	RESOLVING_S

	ld	hl,PARAM_BUFFER
	xor	a
	inl	DNS_Q

	ld	b,a
	ld	ix,DNSQERRS_T
	jr	c,DNSQR_ERR

	;* Espera a que la consulta termine

DNSQ_WAIT:	inl	WAIT_INT
	call	CHECK_KEY

	ld	a,1
	inl	DNS_R

	;* Error?

	ld	b,a
	cp	3
	ld	ix,DNSRERRS_T
	jr	z,DNSQR_ERR

	;* La consulta continua? Vuelve al bucle de espera

	cp	2
	jr	nz,DNSQ_WAIT	;Aun no ha terminado la consulta?

	;* Consulta finalizada? Muestra resultado y sigue

	ld	(HOST_IP),hl	;Guarda resultado
	ld	(HOST_IP+2),de	;devuelto en L.H.E.D

	ld	ix,RESOLVIP_S	;Muestra resultado
	ld	a,"$"
	inl	IP_STRING

	print	RESOLVOK_S
	print	TWO_NL_S
	jp	RESOLV_OK	;Sigue

	;- Rutina de error para DNS_Q y DNS_R
	;  Entrada: B=Codigo de error, IX=Tabla de errores

DNSQR_ERR:	push	ix,bc

	;* Imprime "ERROR <codigo>: "

	ld	ix,RESOLVERRC_S
	call	BYTE2ASC
	ld	(ix),":"
	ld	(ix+1)," "
	ld	(ix+2),"$"
	print	RESOLVERR_S

	;* Obtiene la cadena de error, la imprime, y termina

	pop	bc,de
	call	GET_STRING
	ld	c,_STROUT
	call	5

	jp	TERMINATE
RESOLV_OK:	;

	;--- Salta al modo de envio o de recepcion

	ld	a,(GETPUT)
	or	a
	jp	z,TFTP_GET


	;-------------------------------------------
	;---  Envio de un fichero, modo cliente  ---
	;-------------------------------------------

TFTP_PUT:	;--- Obtiene el nombre del fichero a enviar y lo abre

	ld	a,3
	ld	de,PARAM_BUFFER
	call	EXTPAR
	jp	c,MISSPAR	;Falta el parametro?

	ld	de,PARAM_BUFFER
	call	OPEN
	or	a
	jr	z,OPEN_PUT_OK

	ld	de,ERROPEN_S	;Error al abrir el fichero?
	call	PRINT_DSKERR
	jp	TERMINATE
OPEN_PUT_OK:	;

	ld	a,b
	ld	(FH),a	;Guarda el identificador del fichero

	;--- Obtiene el nombre a anunciar en el envio (4o parametro);
	;    si no se ha especificado, se usara el nombre real
	;    del fichero, que ya esta en PARAM_BUFFER
	;    (quitandole la ruta)

	ld	hl,PARAM_BUFFER	;De momento suponemos que
	ld	(FILEPART_PNT),hl	;nombre envio=real

	ld	a,(PARAM_BUFFER)
	ld	b,a	;EXTPAR pone un 0 en PARAM_BUFFER
	push	bc	;si no hay parametro, en prevencion
	ld	de,PARAM_BUFFER	;de eso guardamos el primer byte
	ld	a,4	;del nombre real del fichero
	call	EXTPAR	;por si hay que restaurarlo
	pop	bc
	jr	nc,TFTP_GET2

	;* No habia cuarto parametro:
	;  Obtenemos la direccion de la parte de fichero
	;  del nombre real (es decir, el nombre real sin la ruta)

	ld	a,b	;Restauramos 1er byte nombre real
	ld	(PARAM_BUFFER),a

	ld	hl,PARAM_BUFFER
	call	GET_FILEPART
	ld	(FILEPART_PNT),hl
TFTP_GET2:	;

	;--- Limpia los paquetes UDP antiguos

	call	FLUSH_UDP

	;--- Escoge un TID (puerto UDP local) aleatorio
	;    y establece el TID remoto a 69

	call	INIT_TIDS_CLIENT

	;--- Compone paquete de peticion de escritura

	ld	hl,#0200	;Codigo de WRQ
	ld	(OUT_BUFFER),hl

	ld	hl,(FILEPART_PNT)	;Copia nombre de fichero
	call	STRLEN
	inc	bc	;Para que incluya 0 final
	push	bc
	ld	hl,(FILEPART_PNT)
	ld	de,OUT_BUFFER+2
	ldir

	ld	hl,OCTET_S	;Anyade "OCTET" al final
	ld	bc,6
	ldir

	pop	bc
	ld	hl,8	;Para que incluya el codigo
	add	hl,bc	;y la cadena "OCTET"
	push	hl
	pop	bc
	call	SEND_TFTP	;Envia paquete

	print	WRQSENT_S

	;--- Inicializa temporizadores

	call	INIT_RETX

	ld	hl,0
	ld	(LAST_BLKID),hl


	;----------------------------------
	;---  Bucle principal de envio  ---
	;----------------------------------

TFTP_PUT_LOOP:		;--- Comprueba si ha llegado un paquete de confirmacion

	call	CHECK_KEY

	call	RCV_TFTP
	jp	c,PUT_LOOP_W	;Salta si no hay paquetes

	;* Si el paquete es de error, lo mostramos y terminamos

	ld	hl,(IN_BUFFER)
	ld	de,#0500
	call	COMP
	jr	nz,NO_PUTERR

	call	SHOW_TFTPE
	call	FCLOSE
	jp	GETPUT_END
NO_PUTERR:	;

	;* Si el paquete es ACK, comprobamos que el ID coincida
	;  con el ultimo enviado

	ld	hl,(IN_BUFFER)
	ld	de,#0400
	call	COMP
	jr	nz,PUT_LOOP_W	;Si no es ACK, lo ignoramos

	ld	a,(IN_BUFFER+2)
	ld	h,a
	ld	a,(IN_BUFFER+3)
	ld	l,a
	ld	de,(LAST_BLKID)
	call	COMP
	jr	nz,PUT_LOOP_W	;Si el ID no coincide, lo ignoramos

	;--- ACK correcto recibido

	;* Si antes habiamos enviado menos de 512 bytes,
	;  ya estamos: terminamos

	ld	hl,(LAST_BLKID)	;Si BLKID=0, aun no habiamos
	ld	a,h	;enviado datos, solo habiamos
	or	l	;enviado la peticion de esritura
	jr	z,NO_LASTBLK

	ld	hl,(LAST_SND_SIZE)
	ld	de,512+4
	call	COMP
	jr	z,NO_LASTBLK

	print	TCOMPLETE_S
	call	FCLOSE
	jp	GETPUT_END
NO_LASTBLK:	;

	;* Enviamos siguiente bloque, que leemos del fichero

SEND_BLOCK:	ld	hl,#0300	;Codigo de DATA
	ld	(OUT_BUFFER),hl

	ld	hl,(LAST_BLKID)	;Ultimo ID de bloque mas uno
	inc	hl
	ld	(LAST_BLKID),hl
	ld	a,h
	ld	(OUT_BUFFER+2),a
	ld	a,l
	ld	(OUT_BUFFER+3),a

	ld	a,(FH)
	ld	b,a
	ld	de,OUT_BUFFER+4
	ld	hl,512
	call	READ	;Intenta leer 512 bytes

	inc	hl	;Para que incluya la cabecera
	inc	hl	;del paquete (codigo DATA+ID bloque)
	inc	hl
	inc	hl
	push	hl
	pop	bc
	call	SEND_TFTP	;Envia paquete

	;--- Muestra informacion de progreso y
	;    vuelve al bucle principal

	call	SHOW_PROGRESS
	jp	TFTP_PUT_LOOP

	;--- No hay paquetes: espera

PUT_LOOP_W:	call	WAIT_TICK
	jp	nc,TFTP_PUT_LOOP

	call	FCLOSE	;Llega aqui en caso de timeout
	jp	GETPUT_END


	;-----------------------------------------------
	;---  Recepcion de un fichero, modo cliente  ---
	;-----------------------------------------------

TFTP_GET:	;--- Obtiene el nombre de fichero a anunciar en la transferencia
			;    y compone el paquete de peticion

	ld	a,3
	ld	de,PARAM_BUFFER
	call	EXTPAR
	jp	c,MISSPAR	;Falta el parametro?

	ld	hl,#0100	;Codigo de RRQ
	ld	(OUT_BUFFER),hl

	ld	hl,PARAM_BUFFER
	call	STRLEN
	inc	bc	;Para que incluya 0 final
	push	bc
	ld	hl,PARAM_BUFFER
	ld	de,OUT_BUFFER+2
	ldir

	ld	hl,OCTET_S	;Anyade "OCTET" al final
	ld	bc,6
	ldir

	pop	bc
	ld	hl,8	;Para que incluya el codigo
	add	hl,bc	;y la cadena "OCTET"
	ld	(LAST_SND_SIZE),hl	;Guardamos la longitud para despues

	;--- Obtiene el nombre del fichero a crear localmente.
	;    Si se especifica cuarto parametro, ese es el que se usa.
	;    Si no, se usa el tercer parametro quitandole la informacion de ruta.

	ld	hl,PARAM_BUFFER	;De momento suponemos que si
	ld	(FILEPART_PNT),hl	;habra cuarto parametro

	ld	a,(PARAM_BUFFER)
	ld	b,a	;EXTPAR pone un 0 en PARAM_BUFFER
	push	bc	;si no hay parametro, en prevencion
	ld	de,PARAM_BUFFER	;de eso guardamos el primer byte
	ld	a,4	;del nombre real del fichero
	call	EXTPAR	;por si hay que restaurarlo
	pop	bc
	jr	nc,TFTP_GET4

	;* No habia cuarto parametro: obtiene la parte
	;  de nombre de fichero del tercer parametro

	ld	a,b
	ld	(PARAM_BUFFER),a
	ld	hl,PARAM_BUFFER
	call	GET_FILEPART
	or		a
	jr	z,TFTP_GET3

	call	PRINT_DSKERR	;No era una ruta correcta: error
	jp	TERMINATE

TFTP_GET3:	;
	ld	(FILEPART_PNT),hl
TFTP_GET4:	;

	;--- Crea el fichero y lo abre

	;* Crea el fichero

	ld	de,(FILEPART_PNT)
	call	CREATE
	or	a
	jr	z,CREATE_GET_OK

	ld	de,ERRCREATE_S	;Error al crear el fichero?
	call	PRINT_DSKERR
	jp	TERMINATE
CREATE_GET_OK:		;

	;* Ahora abre el fichero

	ld	de,(FILEPART_PNT)
	call	OPEN
	or	a
	jr	z,OPEN_GET_OK

	ld	de,ERROPEN_S	;Error al abrir el fichero?
	call	PRINT_DSKERR
	jp	TERMINATE
OPEN_GET_OK:	;

	ld	a,b
	ld	(FH),a

	;--- Limpia los paquetes UDP antiguos

	call	FLUSH_UDP

	;--- Escoge un TID (puerto UDP local) aleatorio
	;    y establece el TID remoto a 69

	call	INIT_TIDS_CLIENT

	;--- Envia paquete de peticion de lectura

	ld	bc,(LAST_SND_SIZE)
	call	SEND_TFTP

	print	RRQSENT_S

	;--- Inicializa temporizadores

	call	INIT_RETX

	ld	hl,0
	ld	(LAST_BLKID),hl


	;--------------------------------------
	;---  Bucle principal de recepcion  ---
	;--------------------------------------

TFTP_GET_LOOP:		;--- Comprueba si ha llegado un paquete de datos

	call	CHECK_KEY

	call	RCV_TFTP
	jp	c,GET_LOOP_W
	ld	(LAST_RCV_SIZE),bc	;Salta si no hay paquetes

	;* Si el paquete es de error, lo mostramos y terminamos

	ld	hl,(IN_BUFFER)
	ld	de,#0500
	call	COMP
	jr	nz,NO_GETERR

	call	SHOW_TFTPE
	call	FCLOSE
	jp	GETPUT_END
NO_GETERR:	;

	;* Si el paquete es de datos, comprobamos que el ID coincida
	;  con el ultimo recibido, mas uno

	ld	hl,(IN_BUFFER)
	ld	de,#0300
	call	COMP
	jr	nz,GET_LOOP_W	;Si no es paquete de datos, lo ignoramos

	ld	a,(IN_BUFFER+2)
	ld	h,a
	ld	a,(IN_BUFFER+3)
	ld	l,a
	ld	de,(LAST_BLKID)
	inc	de
	call	COMP
	jr	nz,GET_LOOP_W	;Si el ID no coincide, lo ignoramos

	ld	(LAST_BLKID),de	;Actualizamos ID

	;--- Datos correctos recibidos

	;* Escribe los datos en el fichero

	ld	hl,(LAST_RCV_SIZE)
	ld	de,4
	or	a
	sbc	hl,de	;Resta la cabecera del tamanyo
	ld	a,h
	or	l
	jr	z,GET_WROK	;Cero: no escribimos nada

	ld	de,IN_BUFFER+4
	ld	a,(FH)
	ld	b,a
	call	WRITE	;Escribe los datos
	or	a
	jr	z,GET_WROK

	call	SEND_DSKERR
	call	PRINT_DSKERR	;Error de disco: envia un error y termina
	call	FCLOSE
	jp	GETPUT_END
GET_WROK:	;

	;--- Envia paquete de ACK

SEND_ACK:	ld	hl,#0400
	ld	(OUT_BUFFER),hl
	ld	hl,(LAST_BLKID)
	ld	a,h
	ld	(OUT_BUFFER+2),a
	ld	a,l
	ld	(OUT_BUFFER+3),a

	ld	bc,4
	call	SEND_TFTP

	;--- Muestra informacion de progreso

	call	SHOW_PROGRESS

	;--- Si el paquete era menor de 512 bytes, ya hemos terminado;
	;    en caso contrario volvemos al bucle principal

	ld	hl,(LAST_RCV_SIZE)
	ld	de,512+4
	call	COMP
	jp	z,TFTP_GET_LOOP

	print	TCOMPLETE_S
	call	FCLOSE
	jp	GETPUT_END

	;--- No hay paquetes: espera

GET_LOOP_W:	call	WAIT_TICK
	jp	nc,TFTP_GET_LOOP

	call	FCLOSE	;Llega aqui en caso de timeout
	;jp      GETPUT_END


	;--- Fin comun para el envio y la recepcion de un fichero.
	;    Si estabamos en modo cliente, terminamos.
	;    Si estabamos en modo servidor, volvemos al bucle de espera.

GETPUT_END:	ld	a,(SERVER)
	or	a
	jp	z,TERMINATE
	jr	TO_SERVER2


	;----------------------------------------
	;---  Modo servidor, bucle de espera  ---
	;----------------------------------------

TO_SERVER:	print	INSERV_S
	ld	a,#FF
	ld	(SERVER),a

TO_SERVER2:	print	WAITING_IN_S

	;--- Espera a que llegue un paquete o a que se pulse una tecla

SRV_MAIN_LOOP:	ld	hl,0	;Inicializa IP y puerto local
	ld	(HOST_IP),hl	;para que RCV_TFTP acepte
	ld	(HOST_IP+2),hl	;paquetes de cualquier host
	ld	hl,69
	ld	(LOCAL_PORT),hl

SRV_MAIN_LOOP2:	call	CHECK_KEY
	or	a
	jp	nz,TERMINATE	;Si se ha pulsado una tecla, terminamos

	call	RCV_TFTP
	jr	c,SRV_MAIN_LOOP2	;Si no hay paquetes, seguimos esperando

	;--- Llega un paquete: comprueba si es peticion
	;    de envio o de recepcion

	ld	hl,(IN_BUFFER)
	ld	de,#0200	;Peticion de escritura
	call	COMP
	jr	z,SRV_WRQ_RCVD

	ld	de,#0100	;Peticion de lectura
	call	COMP
	jr	nz,SRV_MAIN_LOOP


	;---------------------------------------------------------
	;---  Modo servidor, recepcion de peticion de lectura  ---
	;---------------------------------------------------------

SRV_RRQ_RCVD:	print	RRQRCVD_S	;Imprime la IP del host
	ld	de,IN_BUFFER+2
	call	PRINTZ
	print	ONE_NL_S

	;--- Comprueba si el fichero requerido existe

	ld	de,IN_BUFFER+2
	ld	b,0
	xor	a
	ld	ix,PARAM_BUFFER
	call	DIR
	or	a
	jr	z,RRQ_OK_1

	;* No existe: enviamos error y volvemos al bucle de espera

	ld	a,1
	ld	de,FNOTF_S
	call	SEND_ERR

	ld	de,FNOTF_S
	call	PRINTZ
	print	TWO_NL_S
	jp	TO_SERVER2
RRQ_OK_1:	;

	;--- Abrimos el fichero

	ld	de,IN_BUFFER+2
	call	OPEN
	or	a
	jr	z,RRQ_OK_2

	push	af	;Error?
	call	SEND_DSKERR
	pop	af
	ld	de,ERROPEN_S
	call	PRINT_DSKERR
	print	ONE_NL_S
	jp	TO_SERVER2
RRQ_OK_2:	;

	ld	a,b
	ld	(FH),a

	;--- Saltamos al bucle principal de envio
	;    del modo cliente (saltamos a SEND_BLOCK, el punto en
	;    el que en teoria ya se ha recibido el ACK de la peticion
	;    que habriamos enviado de estar en modo cliente)

	call	INIT_RETX

	ld	hl,0
	ld	(LAST_BLKID),hl

	ld	a,#FF
	ld	(GETPUT),a

	jp	SEND_BLOCK


	;-----------------------------------------------------------
	;---  Modo servidor, recepcion de peticion de escritura  ---
	;-----------------------------------------------------------

SRV_WRQ_RCVD:	print	WRQRCVD_S	;Imprime la IP del host
	ld	de,IN_BUFFER+2
	call	PRINTZ
	print	ONE_NL_S

	;--- Creamos el fichero requerido y despues lo abrimos

	;* Lo creamos

	ld	de,IN_BUFFER+2
	call	CREATE
	or	a
	ld	de,ERRCREATE_S
	jr	nz,WRQ_ERR

	;* Ahora lo abrimos

	ld	de,IN_BUFFER+2
	call	OPEN
	or	a
	ld	de,ERROPEN_S
	jr	z,WRQ_OK_2

WRQ_ERR:	push	af,de	;Error al abrir o al crear?
	call	SEND_DSKERR
	pop	de,af
	call	PRINT_DSKERR
	print	ONE_NL_S
	jp	TO_SERVER2
WRQ_OK_2:	;

	ld	a,b
	ld	(FH),a

	;--- Saltamos al bucle principal de recepcion
	;    del modo cliente

	call	INIT_RETX

	ld	hl,0
	ld	(LAST_BLKID),hl

	xor	a
	ld	(GETPUT),a

	;* Para que el codigo del bucle de recepcion no termine
	;  prematuramente, le hacemos creer que previamente
	;  hemos recibido un paquete de datos con 512 bytes

	ld	hl,512+4
	ld	(LAST_RCV_SIZE),hl

	jp	SEND_ACK


;******************************
;***                        ***
;***   RUTINAS AUXILIARES   ***
;***                        ***
;******************************

;--- Rutina de conexion de un segmento en pagina 1, si se obtiene
;    desde la zona de trabajo de INl en pagina 3 no hay que preocuparse
;    de si estamos en DOS 1 o en DOS 2

PUT_P1:	ds	3


;--- Terminacion del programa

	;* Parametro invalido

INVPAR:	print	INVPAR_S
	jp	TERMINATE

	;* Falta un parametro

MISSPAR:	print	MISSPAR_S
	jp	TERMINATE

	;* Rutina generica de terminacion

TERMINATE:	ld	a,2
	call	PUT_P1

	ld	a,(DOS2)	;En DOS 2, antes hay que
	or	a	;cancelar la rutina de control
	ld	de,0	;de CTRL-STOP o cancelacion
	ld	c,_DEFAB	;de un error de disco
	call	nz,5

	call	FCLOSE

	;* Salta aqui si aun no hemos obtenido PUT_P1

TERMIN2:	ld	c,_TERM0
	jp	5


;--- Rutina de control de pulsacion de CTRL-STOP o de cancelacion
;    de un error de disco en DOS 2: simplemente nos aseguramos
;    de que el programa terminara a traves de TERMINATE,
;    para que se cierre el fichero que haya abierto y se restaure
;    TPA en pagina 1 antes de volver al DOS.

TERM_AB:	pop	hl
	ld	de,GENERR_S
	call	PRINT_DSKERR	;De paso mostramos el error
	jp	TERMINATE


;--- PRINTZ: Imprime una cadena acabada en "0"
;            Entrada: DE = Cadena

PRINTZ:	ld	a,(de)
	or	a
	ret	z
	push	de
	ld	e,a
	ld	c,2
	call	5
	pop	de
	inc	de
	jr	PRINTZ


;--- NOMBRE: EXTPAR
;      Extraccion de un parametro de la linea de comandos
;    ENTRADA:   A  = Parametro a extraer (el primero es el 1)
;               DE = Bufer para dejar el parametro
;    SALIDA:    A  = Numero de parametros
;               CY = 1 -> No existe ese parametro
;                         B indefinido, bufer inalterado
;               CY = 0 -> B = Longitud del parametro (no incluye el 0)
;                         Parametro a partir de DE, acabado en 0
;    REGISTROS: -
;    LLAMADAS:  -

EXTPAR:	or	a	;Volvemos con error si A = 0
	scf
	ret	z

	ld	b,a
	ld	a,(#80)	;Volvemos con error si no hay parametros
	or	a
	scf
	ret	z
	ld	a,b

	push	af,hl
	ld	a,(#80)
	ld	c,a	;Ponemos un 0 al final
	ld	b,0	;(necesario en DOS 1)
	ld	hl,#81
	add	hl,bc
	ld	(hl),0
	pop	hl,af

	push	hl,de,ix
	ld	ix,0	;IXl: Numero de parametros    
	ld	ixh,a	;IXh: Parametro a extraer    
	ld	hl,#81

PASASPC:	ld	a,(hl)	;Vamos pasando espacios    
	or	a
	jr	z,ENDPNUM
	cp	" "
	inc	hl
	jr	z,PASASPC

	inc	ix
PASAPAR:	ld	a,(hl)	;Vamos pasando el parametro    
	or	a
	jr	z,ENDPNUM
	cp	" "
	inc	hl
	jr	z,PASASPC
	jr	PASAPAR

ENDPNUM:	ld	a,ixh	;Error si se el parametro a extraer    
	dec	a	;(anyadido para quitar el jrmy)
	cp	ixl	;es mayor que el numero de parametros    
	jr	nc,EXTPERR
	;jrmy   EXTPERR          ;existentes    

	ld	hl,#81
	ld	b,1	;B = parametro actual    
PASAP2:	ld	a,(hl)	;Pasamos espacios hasta dar    
	cp	" "	;con el siguiente parametro    
	inc	hl
	jr	z,PASAP2

	ld	a,ixh	;Si es el que buscamos lo extraemos.    
	cp	B	;Si no ...    
	jr	z,PUTINDE0

	inc	B
PASAP3:	ld	a,(hl)	;... lo pasamos y volvemos a PAPAP2    
	cp	" "
	inc	hl
	jr	nz,PASAP3
	jr	PASAP2

PUTINDE0:	ld	b,0
	dec	hl
PUTINDE:	inc	b
	ld	a,(hl)
	cp	" "
	jr	z,ENDPUT
	or	a
	jr	z,ENDPUT
	ld	(de),a	;Ponemos el parametro a partir de (DE)    
	inc	de
	inc	hl
	jr	PUTINDE

ENDPUT:	xor	a
	ld	(de),a
	dec	b

	ld	a,ixl
	or	a
	jr	FINEXTP
EXTPERR:	scf
FINEXTP:	pop	ix,de,hl
	ret


;--- BYTE2ASC: Conversion del numero A en una cadena sin terminacion
;    Deposita la cadena en (IX), y modifica IX para que apunte tras la cadena
;    Modifica: C

BYTE2ASC:	cp	10
	jr	c,B2A_1D
	cp	100
	jr	c,B2A_2D
	cp	200
	jr	c,B2A_1XX
	jr	B2A_2XX

	;--- Un digito

B2A_1D:	add	"0"
	ld	(ix),a
	inc	ix
	ret

	;--- Dos digitos

B2A_2D:	ld	c,"0"
B2A_2D2:	inc	c
	sub	10
	cp	10
	jr	nc,B2A_2D2

	ld	(ix),c
	inc	ix
	jr	B2A_1D

	;--- Entre 100 y 199

B2A_1XX:	ld	(ix),"1"
	sub	100
B2A_XXX:	inc	ix
	cp	10
	jr	nc,B2A_2D	;Si es 1XY con X>0
	ld	(ix),"0"	;Si es 10Y
	inc	ix
	jr	B2A_1D

	;--- Entre 200 y 255

B2A_2XX:	ld	(ix),"2"
	sub	200
	jr	B2A_XXX


;--- NOMBRE: COMP
;      Comparacion de HL con DE (16 bits sin signo)
;    ENTRADA:   HL, DE = numeros a comparar
;    SALIDA:     C, NZ si HL > DE
;                C,  Z si HL = DE
;               NC, NZ si HL < DE
;    REGISTROS: -

COMP:	call	_COMP
	ccf
	ret

_COMP:	ld	a,h
	sub	d
	ret	nz
	ld	a,l
	sub	e
	ret


;--- GET_STRING: Devuelve una cadena asociada a un numero, o "Unknown".
;    Entrada: DE = Puntero a la tabla de cadenas y numeros, con el formato:
;                  db num,"Cadena$"
;                  db num2,"Cadena2$"
;                  ...
;                  db 0
;             B = Numero asociado
;    Salida:  DE = Puntero a la cadena

GET_STRING:	ld	a,(de)
	inc	de
	or	a	;No encontramos el codigo: mostramos "Unknown"
	jr	nz,LOOP_GETS2
	ld	de,STRUNK_S
	ret

LOOP_GETS2:	cp	b	;Coincide?
	ret	z

LOOP_GETS3:	ld	a,(de)	;No: pasa al siguiente
	inc	de
	cp	"$"
	jr	nz,LOOP_GETS3
	jr	GET_STRING

STRUNK_S:	db	"Unknown$"


;--- NOMBRE: NUMTOASC
;      Conversion de un entero de 16 bits a una cadena de caracteres
;    ENTRADA:    DE = Numero a convertir
;                HL = Buffer para depositar la cadena
;                B  = Numero total de caracteres de la cadena
;                     sin incluir signos de terminacion
;                C  = Caracter de relleno
;                     El numero se justifica a la derecha, y los
;                     espacios sobrantes se rellenan con el caracter (C).
;                     Si el numero resultante ocupa mas caracteres que
;                     los indicados en B, este registro es ignorado
;                     y la cadena ocupa los caracteres necesarios.
;                     No se cuenta el caracter de terminacion, "$" o 00,
;                     a efectos de longitud.
;                 A = &B ZPRFFTTT
;                     TTT = Formato del numero resultante
;                            0: decimal
;                            1: hexdecimal
;                            2: hexadecimal, comenzando con "&H"
;                            3: hexadecimal, comenzando con "#"
;                            4: hexadecimal, acabado en "H"
;                            5: binario
;                            6: binario, comenzando con "&B"
;                            7: binario, acabado en "B"
;                     R   = Rango del numero
;                            0: 0..65535 (entero sin signo)
;                            1: -32768..32767 (entero en complemento a dos)
;                               Si el formato de salida es binario,
;                               el numero se interpreta como entero de 8 bits
;                               y el rango es 0..255. Es decir, el bit R
;                               y el registro D son ignorados.
;                     FF  = Tipo de finalizacion de la cadena
;                            0: Sin finalizacion especial
;                            1: Adicion de un caracter "$"
;                            2: Adicion de un caracter 00
;                            3: Puesta a 1 del 7o bit del ultimo caracter
;                     P   = Signo "+"
;                            0: No agnadir un signo "+" a los numeros positivos
;                            1: Agnadir un signo "+" a los numeros positivos
;                     Z   = Ceros sobrantes
;                            0: Quitar ceros a la izquierda
;                            1: No quitar ceros a la izquierda
;    SALIDA:    Cadena a partir de (HL)
;               B = Numero de caracteres de la cadena que forman
;                   el numero, incluyendo el signo y el indicador
;                   de tipo si son generados
;               C = Numero de caracteres totales de la cadena
;                   sin contar el "$" o el 00 si son generados
;    REGISTROS: -

NUMTOASC:	push	af,ix,de,hl
	ld	ix,WorkNTOA
	push	af,af
	and	%00000111
	ld	(ix+0),a	;Tipo 
	pop	af
	and	%00011000
	rrca
	rrca
	rrca
	ld	(ix+1),a	;Fin 
	pop	af
	and	%11100000
	rlca
	rlca
	rlca
	ld	(ix+6),a	;Banderas: Z(cero), P(signo +), R(rango) 
	ld	(ix+2),b	;No. caracteres finales 
	ld	(ix+3),c	;Caracter de relleno 
	xor	a
	ld	(ix+4),a	;Longitud total 
	ld	(ix+5),a	;Longitud del numero 
	ld	a,10
	ld	(ix+7),a	;Divisor a 10 
	ld	(ix+13),l	;Buffer pasado por el usuario 
	ld	(ix+14),h
	ld	hl,BufNTOA
	ld	(ix+10),l	;Buffer de la rutina 
	ld	(ix+11),h

ChkTipo:	ld	a,(ix+0)	;Divisor a 2 o a 16, o dejar a 10 
	or	a
	jr	z,ChkBoH
	cp	5
	jp	nc,EsBin
EsHexa:	ld	a,16
	jr	GTipo
EsBin:	ld	a,2
	ld	d,0
	res	0,(ix+6)	;Si es binario esta entre 0 y 255 
GTipo:	ld	(ix+7),a

ChkBoH:	ld	a,(ix+0)	;Comprueba si hay que poner "H" o "B" 
	cp	7	;al final 
	jp	z,PonB
	cp	4
	jr	nz,ChkTip2
PonH:	ld	a,"H"
	jr	PonHoB
PonB:	ld	a,"B"
PonHoB:	ld	(hl),a
	inc	hl
	inc	(ix+4)
	inc	(ix+5)

ChkTip2:	ld	a,d	;Si el numero es 0 nunca se pone signo 
	or	e
	jr	z,NoSgn
	bit	0,(ix+6)	;Comprueba rango   
	jr	z,SgnPos
ChkSgn:	bit	7,d
	jr	z,SgnPos
SgnNeg:	push	hl	;Niega el numero 
	ld	hl,0	;Signo=0:sin signo; 1:+; 2:-   
	xor	a
	sbc	hl,de
	ex	de,hl
	pop	hl
	ld	a,2
	jr	FinSgn
SgnPos:	bit	1,(ix+6)
	jr	z,NoSgn
	ld	a,1
	jr	FinSgn
NoSgn:	xor	a
FinSgn:	ld	(ix+12),a

ChkDoH:	ld	b,4
	xor	a
	cp	(ix+0)
	jp	z,EsDec
	ld	a,4
	cp	(ix+0)
	jp	nc,EsHexa2
EsBin2:	ld	b,8
	jr	EsHexa2
EsDec:	ld	b,5

EsHexa2:	push	de
Divide:	push	bc,hl	;DE/(IX+7)=DE, resto A 
	ld	a,d
	ld	c,e
	ld	d,0
	ld	e,(ix+7)
	ld	hl,0
	ld	b,16
BucDiv:	rl	c
	rla
	adc	hl,hl
	sbc	hl,de
	jr	nc,$+3
	add	hl,de
	ccf
	djnz	BucDiv
	rl	c
	rla
	ld	d,a
	ld	e,c
	ld	a,l
	pop	hl,bc

ChkRest9:	cp	10	;Convierte el resto en caracter 
	jp	nc,EsMay9
EsMen9:	add	a,"0"
	jr	PonEnBuf
EsMay9:	sub	10
	add	a,"A"

PonEnBuf:	ld	(hl),a	;Pone caracter en buffer 
	inc	hl
	inc	(ix+4)
	inc	(ix+5)
	djnz	Divide
	pop	de

ChkECros:	bit	2,(ix+6)	;Comprueba si hay que eliminar ceros 
	jr	nz,ChkAmp
	dec	hl
	ld	b,(ix+5)
	dec	b	;B=no. de digitos a comprobar 
Chk1Cro:	ld	a,(hl)
	cp	"0"
	jr	nz,FinECeros
	dec	hl
	dec	(ix+4)
	dec	(ix+5)
	djnz	Chk1Cro
FinECeros:	inc	hl

ChkAmp:	ld	a,(ix+0)	;Coloca "#", "&H" o "&B" si es necesario 
	cp	2
	jr	z,PonAmpH
	cp	3
	jr	z,PonAlm
	cp	6
	jr	nz,PonSgn
PonAmpB:	ld	a,"B"
	jr	PonAmpHB
PonAlm:	ld	a,"#"
	ld	(hl),a
	inc	hl
	inc	(ix+4)
	inc	(ix+5)
	jr	PonSgn
PonAmpH:	ld	a,"H"
PonAmpHB:	ld	(hl),a
	inc	hl
	ld	a,"&"
	ld	(hl),a
	inc	hl
	inc	(ix+4)
	inc	(ix+4)
	inc	(ix+5)
	inc	(ix+5)

PonSgn:	ld	a,(ix+12)	;Coloca el signo 
	or	a
	jr	z,ChkLon
SgnTipo:	cp	1
	jr	nz,PonNeg
PonPos:	ld	a,"+"
	jr	PonPoN
	jr	ChkLon
PonNeg:	ld	a,"-"
PonPoN	ld	(hl),a
	inc	hl
	inc	(ix+4)
	inc	(ix+5)

ChkLon:	ld	a,(ix+2)	;Pone caracteres de relleno si necesario 
	cp	(ix+4)
	jp	c,Invert
	jr	z,Invert
PonCars:	sub	(ix+4)
	ld	b,a
	ld	a,(ix+3)
Pon1Car:	ld	(hl),a
	inc	hl
	inc	(ix+4)
	djnz	Pon1Car

Invert:	ld	l,(ix+10)
	ld	h,(ix+11)
	xor	a	;Invierte la cadena 
	push	hl
	ld	(ix+8),a
	ld	a,(ix+4)
	dec	a
	ld	e,a
	ld	d,0
	add	hl,de
	ex	de,hl
	pop	hl	;HL=buffer inicial, DE=buffer final 
	ld	a,(ix+4)
	srl	a
	ld	b,a
BucInv:	push	bc
	ld	a,(de)
	ld	b,(hl)
	ex	de,hl
	ld	(de),a
	ld	(hl),b
	ex	de,hl
	inc	hl
	dec	de
	pop	bc
	ld	a,b
	or	a
	jr	z,ToBufUs
	djnz	BucInv
ToBufUs:	ld	l,(ix+10)
	ld	h,(ix+11)
	ld	e,(ix+13)
	ld	d,(ix+14)
	ld	c,(ix+4)
	ld	b,0
	ldir
	ex	de,hl

ChkFin1:	ld	a,(ix+1)	;Comprueba si ha de acabar en "$" o en 0  
	and	%00000111
	or	a
	jr	z,Fin
	cp	1
	jr	z,PonDolar
	cp	2
	jr	z,PonChr0

PonBit7:	dec	hl
	ld	a,(hl)
	or	%10000000
	ld	(hl),a
	jr	Fin

PonChr0:	xor	a
	jr	PonDo0
PonDolar:	ld	a,"$"
PonDo0:	ld	(hl),a
	inc	(ix+4)

Fin:	ld	b,(ix+5)
	ld	c,(ix+4)
	pop	hl,de,ix,af
	ret

WorkNTOA:	defs	16
BufNTOA:	ds	10


;--- STRLEN: Devuelve en BC la longitud de la cadena
;    apuntada por HL, acabada en 0

STRLEN:	ld	bc,0
STRLEN2:	ld	a,(hl)
	or	a
	ret	z
	inc	hl
	inc	bc
	jr	STRLEN2


;--- NOMBRE: CLBUF
;      Limpia el buffer generico para las operaciones de disco
;    ENTRADA:   -
;    SALIDA:    -
;    REGISTROS: -

CLBUF:	push	hl,de,bc
	ld	hl,DISK_BUFFER
	ld	de,DISK_BUFFER+1
	ld	bc,70-1
	ld	(hl),0
	ldir
	pop	bc,de,hl
	ret


;--- NOMBRE: MIN2MAY
;      Convierte un caracter a mayuscula
;    ENTRADA:   A = Caracter
;    SALIDA:    A = Caracter en mayuscula si era minuscula,
;                   inalterado si no
;    REGISTROS: F

MIN2MAY:	cp	ENYEMIN
	jp	nz,NOENYE
	ld	a,ENYEMAY
	ret
NOENYE:	cp	"a"
	ret	c
	cp	"z"+1
	ret	nc
	and	%11011111
	ret


;--- NOMBRE: CONVNAME
;      Convierte un nombre de fichero de/a formato FCB
;      NO comprueba caracteres invalidos en el nombre del fichero
;    ENTRADA:    HL = Cadena de origen
;                     Formato FCB:    12 caracteres, sin punto
;                                     (los sobrantes se rellenan con espacios)
;                                     El primero es la unidad
;                                     (0: defecto, 1: A, 2: B, etc)
;                     Formato normal: Acabada en 0, maximo 14 caracteres
;                                     Comienza con la unidad y ":"
;                                     si no es la idem por defecto (la 0)
;                DE = Cadena de destino (idem)
;                Cy = 0 -> Formato normal a FCB
;                Cy = 1 -> Formato FCB a normal
;     SALIDA:    B  = Longitud de la cadena de destino
;                     Formato FCB: siempre 12
;                     Formato normal: no incluye el 0 final
;     REGISTROS: AF, C

CONVNAME:	push	de,hl
	jp	c,FCB2NOR
	xor	a
	ld	(EXTFLG),a
	jp	NOR2FCB
ENDCONV:	pop	hl,de
	ret

;--- Conversion nombre normal a nombre FCB

NOR2FCB:	push	de,hl,de	;Rellena de espacios la zona del nombre
	pop	hl
	inc	de
	ld	a," "
	ld	(hl),a
	ld	bc,11
	ldir
	pop	hl,de
	xor	a
	ld	(de),a	;Pone a 0 la unidad

	inc	hl	;Comprueba si se ha especificado unidad.
	ld	a,(hl)	;Si es asi, la convierte al numero
	cp	":"	;de unidad correspondiente.
	jp	nz,NOUN1
	dec	hl
	ld	a,(hl)
	call	MIN2MAY
	sub	"A"-1
	ld	(de),a
	inc	hl
	inc	hl
	inc	hl

NOUN1:	inc	de
	dec	hl
	xor	a	;Bucle para el nombre
	ld	(EXTFLG),a
	ld	b,8
	call	N2FBUC

	ld	a,(EXTFLG)	;Si se ha llegado al final, no procesa
	or	a	;la extension
	jp	nz,ENDCONV
	ld	a,#FF
	ld	(EXTFLG),a
	ld	b,3	;Bucle para la extension
	call	N2FBUC
	ld	b,12
	jp	ENDCONV
;                                   ;Pasa sin convertir los 8 o 3 primeros
N2FBUC:	ld	a,(hl)	;caracteres, a no ser que encuentre
	inc	hl
	cp	"*"	;un 0 (fin de cadena),
	jp	z,AFND1	;un punto (fin de nombre),
	cp	"."	;o un asterisco (que convierte en "?")
	jp	z,PFND1
	or	a
	jp	z,EFND1
	call	MIN2MAY
	ld	(de),a
	inc	de
	djnz	N2FBUC

PASASOB:	ld	a,(EXTFLG)	;Si es la extension no hay nada que pasar
	or	a
	ret	nz

	ld	a,(hl)	;Pasa caracteres sobrantes (mas alla de 8
	inc	hl	;o 3) en el nombre del fichero
	or	a
	jp	z,EFND1
	cp	"."
	jp	nz,PASASOB
	ret

AFND1:	ld	a,"?"	;Rellena de "?" hasta completar
AFND11:	ld	(DE),a	;8 o 3 caracteres
	inc	DE
	djnz	AFND11
	jp	PASASOB

PFND1:	ld	a,(EXTFLG)
	or	a
	jp	nz,EFND1
	ld	a,b
	cp	8	;Si el punto esta al principio,
	dec	hl
	jp	z,AFND1	;interpreta "*.<ext>"
	inc	hl
	ld	a," "	;Rellena de " " hasta completar
PFND11:	ld	(DE),a	;8 o 3 caracteres
	inc	de
	djnz	PFND11
	ret

EFND1:	ld	a,1
	ld	(EXTFLG),a
	ret

EXTFLG:	db	0	;#FF cuando se procesa la extension, 
;                                   ;1 cuando se ha llegado al final

;--- Conversion nombre FCB a nombre normal

FCB2NOR:	push	de
	ld	a,(hl)
	or	a
	jp	z,NOUN2
	add	"A"-1
	ld	(de),a
	inc	de
	ld	a,":"
	ld	(de),a
	inc	de

NOUN2:	inc	hl
	ld	b,8	;Vamos copiando el nombre tal cual
F2NBUC:	ld	a,(hl)	;hasta que pasamos ocho caracteres
	inc	hl	;o encontramos un espacio...
	cp	" "
	jp	z,SPFND
	ld	(de),a
	inc	de
	djnz	F2NBUC
	ld	a,"."
	ld	(de),a
	inc	de
	jp	F2NEXT

SPFND:	ld	a,"."	;...entonces ponemos el punto,
	ld	(de),a	;y pasamos los espacios sobrantes
	inc	de	;hasta llegar a la extension.
SFBUC:	ld	a,(hl)
	inc	hl
	djnz	SFBUC
	dec	hl

F2NEXT:	ld	b,3	;Copiamos la extension hasta haber
F2NEX2:	ld	a,(hl)	;copiado tres caracteres,
	inc	hl	;o hasta encontrar un espacio.
	cp	" "
	jp	z,F2NEND
	ld	(de),a
	inc	de
	djnz	F2NEX2

F2NEND:	dec	de	;Si no hay extension, suprimimos el punto.
	ld	a,(de)
	cp	"."
	jp	z,NOPUN
	inc	de
NOPUN:	xor	a
	ld	(de),a

	ex	de,hl	;Obtencion de la longitud de la cadena.
	pop	de
	or	a
	sbc	hl,de
	ld	b,l
	jp	ENDCONV


;--- NOMBRE: DIR
;      Busca un fichero
;      Siempre se debe ejecutar primero con A=0
;      Para buscar los siguientes, DISK_BUFFER no debe ser modificado
;    ENTRADA:    DE = Nombre del fichero (puede contener comodines), con fin 0
;                IX = Puntero a una zona vacia de 26 bytes
;                B  = Atributos de busqueda (ignorado si DOS 1)
;                A  = 0 -> Buscar primero
;                A  = 1 -> Buscar siguientes
;    SALIDA:     A  = 0 -> Fichero encontrado
;                A <> 0 -> Fichero no encontrado
;                IX+0          -> #FF (fanzine propio del DOS 2)
;                IX+1  a IX+13 -> Nombre del fichero
;                IX+14         -> Byte de atributos
;                IX+15 y IX+16 -> Hora de modificacion
;                IX+17 y IX+18 -> Fecha de modificacion
;                IX+19 y IX+20 -> Cluster inicial
;                IX+21 a IX+24 -> Longitud del fichero
;                IX+25         -> Unidad logica
;     REGISTROS: F,C

OFBUF1:	equ	38

DIR:	ld	c,a
	ld	a,(DOS2)
	or	a
	ld	a,c
	jp	nz,DIR2

	;--- DIR: Version DOS 1

DIR1:	push	bc,de,hl,iy,ix,af
	call	CLBUF
	ex	de,hl
	ld	de,DISK_BUFFER	;Pasamos el nombre normal de (DE)
	or	a	;a nombre FCB en BUFFER.
	call	CONVNAME

	ld	de,DISK_BUFFER+OFBUF1	;Ponemos el area de transferencia
	ld	c,_SETDTA	;en el buffer, tras el FCB del fichero
	call	5	;a buscar.
	ld	de,DISK_BUFFER
	pop	af
	and	1
	ld	c,_SFIRST
	add	c
	ld	c,a
	call	5
	or	a	;Terminamos con A=#FF si no se encuentra.
	jp	nz,ENDFF1

	ld	a,(DISK_BUFFER+OFBUF1)	;Guardamos la unidad del FCB
	ld	(ULO1),a	;en ULO1, y la ponemos a 0
	xor	a	;para poder convertirla a nombre normal
	ld	(DISK_BUFFER+OFBUF1),a	;sin unidad.
	ld	iy,DISK_BUFFER+OFBUF1

	push	iy
	pop	hl	;HL = Entrada de directorio del fichero
	pop	de	;(comenzando con la unidad a 0 y el nombre).
	push	de	;DE = IX de la entrada (buffer del usuario).
	ld	a,#FF
	ld	(de),a	;Primer byte a #FF para igualarlo al DOS 2.
	inc	de
	scf		;Copiamos nombre en formato normal
	call	CONVNAME	;al buffer del usuario.

	pop	ix	;IX = buffer de usuario.
	ld	a,(iy+12)	;Copiamos byte de atributos.
	ld	(ix+14),a

	push	iy
	pop	hl
	ld	bc,23	;HL = Entrada de directorio apuntando a
	add	hl,bc	;la hora de creacion.

	push	ix
	pop	de
	ld	bc,15	;DE = Buffer del usuario apuntando a
	ex	de,hl	;la posicion +15.
	add	hl,bc
	ex	de,hl

	ld	bc,10	;Copiamos fecha,hora,cluster inicial
	ldir		;y longitud a la vez.

	ld	a,(ULO1)	;Copiamos unidad logica.
	ld	(ix+25),a

	xor	a	;Terminamos sin error.
	push	ix
ENDFF1:	pop	ix,iy,hl,de,bc
	ret

ULO1:	db	0

	;--- DIR: Version DOS 2

DIR2:	push	hl,bc,de,ix
	ld	ix,DISK_BUFFER
	ld	c,_FFIRST
	and	1
	add	c
	ld	c,a
	call	5
	or	a
	jp	nz,ENDFF2
	push	ix
	pop	hl
	pop	de
	push	de
	ld	bc,26
	ldir
	xor	a
ENDFF2:	pop	ix,de,bc,hl
	ret


;--- NOMBRE: CREATE
;      Crea un fichero pero NO lo deja abierto
;      !CUIDADU! Si ya existe ese fichero, lo borra y crea uno nuevo
;    ENTRADA:   DE = Nombre del fichero
;    SALIDA:    A  = 0 -> Fichero creado
;               A <> 0 -> Error
;    REGISTROS: F

CREATE:	ld	a,(DOS2)
	or	a
	jp	nz,CREA2

	;--- CREATE: Version DOS 1

CREA1:	push	bc,de,hl,ix,iy
	call	CLBUF
	ex	de,hl	;HL = Nombre del fichero 
	ld	de,DISK_BUFFER
	or	a
	call	CONVNAME
	ex	de,hl
	ld	de,DISK_BUFFER
	push	de
	ld	c,_FMAKE	;Crea el fichero y lo cierra
	call	5
	pop	de
	or	a
	jp	nz,CR1END
	ld	c,_FCLOSE
	call	5
	xor	a
CR1END:	pop	iy,ix,hl,de,bc
	ret

	;--- CREATE: Version DOS 2

CREA2:	push	bc,de,hl
	xor	a
	ld	b,0	;Si el fichero ya existe, lo borra.
	ld	c,_CREATE	;Crea el fichero y lo cierra
	call	5
	or	a	;si no hay error.
	jp	nz,CR2END
	ld	c,_CLOSE
	call	5
	xor	a
CR2END:	pop	hl,de,bc
	ret


;--- NOMBRE: OPEN
;      Abre un fichero
;    ENTRADA:   DE = Fichero a abrir
;    SALIDA:    A  = 0 -> Error
;               A <> 0 -> Error
;                         DOS 1: A=1 -> demasiados ficheros abiertos
;               B  = Numero asociado al fichero
;                    (no tiene nada que ver con el numero de ficheros abiertos)
;    REGISTROS: F, C

OPEN:	ld	a,(DOS2)
	or	a
	jp	nz,OPEN2

	;--- OPEN: Version DOS 1

OPEN1:	ld	a,(NUMFILES)
	cp	MAXFILES
	ld	a,1
	ret	nc

	push	hl,de,ix,iy
	ld	b,MAXFILES
	ld	hl,FCBS
	push	de
	ld	de,38
OP1BUC1:	ld	a,(hl)	;Buscamos, en todos los FCBs,
	or	a	;alguno que este libre.
	jp	z,FCBFND
	add	hl,de
	djnz	OP1BUC1
	ld	a,1
	jp	OP1END

FCBFND:	push	hl	;Limpiamos FCB
	pop	de
	push	de
	inc	de
	ld	bc,37
	ld	(hl),0
	ldir

	pop	de
	inc	de
	pop	hl	;Pasamos el nombre del fichero al FCB
	or	a
	call	CONVNAME

	push	de
	ld	c,_FOPEN
	call	5
	pop	ix
	or	a	;Terminamos si hay error
	jp	nz,OP1END

	ld	a,1
	ld	(ix+14),a	;Ponemos a 1 "record size"
	xor	a
	ld	(ix+15),a
	ld	(ix+33),a	;Ponemos a 0 "random record"
	ld	(ix+34),a
	ld	(ix+35),a
	ld	(ix+36),a

	ld	a,#FF	;Marcamos el FCB como usado
	ld	(ix-1),a

	ld	a,(NUMFILES)	;Incrementamos el numero
	inc	a	;de ficheros abiertos y
	ld	(NUMFILES),a	;devolvemos en A el numero de este
	ld	b,a
	xor	a

OP1END:	pop	iy,ix,de,hl
	ret

	;--- OPEN: Version DOS 2

OPEN2:	push	hl,de
	xor	a
	ld	c,_OPEN
	call	5
	or	a
	jp	nz,OP2END
	ld	a,(NUMFILES)
	inc	a
	ld	(NUMFILES),a
	xor	a
OP2END:	pop	de,hl
	ret


;--- NOMBRE: CLOSE
;      Cierra un fichero
;    ENTRADA:   B  = Numero de fichero
;    SALIDA:    A  = 0 -> Fichero cerrado
;               A <> 0 -> Error
;    REGISTROS: F

CLOSE:	ld	a,(DOS2)
	or	a
	jp	nz,CLOSE2

	;--- CLOSE: Version DOS 1

CLOSE1:	ld	a,b	;Error si B>MAXFILES
	cp	MAXFILES+1	;o B=0.
	ld	a,2
	ret	nc
	ld	a,b
	or	a
	ld	a,2
	ret	z

	push	bc,de,hl,ix,iy
	ld	hl,FCBS
	ld	de,38
	or	a
	sbc	hl,de
CL1BUC1:	add	hl,de	;HL = Zona en FCBS del fichero B
	djnz	CL1BUC1

	ld	a,(hl)	;Error si el fichero no esta abierto
	or	a
	ld	a,2
	jp	z,ENDCL1

	inc	hl
	ex	de,hl	;DE = FCB del fichero
	push	de
	ld	c,_FCLOSE
	call	5
	pop	ix
	or	a
	jp	nz,ENDCL1

	ld	a,(NUMFILES)
	dec	a
	ld	(NUMFILES),a
	xor	a	;Marcamos el FCB como libre
	ld	(ix-1),a

ENDCL1:	pop	iy,ix,hl,de,bc
	ret

	;--- CLOSE: Version DOS 2

CLOSE2:	push	bc,de,hl
	ld	c,_CLOSE
	call	5
	or	a
	jp	nz,ENDCL2
	ld	a,(NUMFILES)
	dec	a
	ld	(NUMFILES),a
	xor	a
ENDCL2:	pop	hl,de,bc
	ret


;--- NOMBRE: READ
;      Lee de un fichero abierto
;    ENTRADA:   B  = Numero de fichero
;               DE = Direccion del bufer
;               HL = Numero de bytes a leer
;    SALIDA:    A  = 0 -> No hay error
;               A <> 0 -> Error
;                         Se considera error no haber podido leer
;                         todos los bytes requeridos, es decir,
;                         HL a la entrada <> HL a la salida.
;                         Este error tiene el codigo A=1
;                         tanto en DOS 1 como en DOS 2.
;               HL = Numero de bytes leidos
;    REGISTROS: F

READ:	ld	a,(DOS2)
	or	a
	jp	nz,READ2

	;--- READ: Version DOS 1 

READ1:	ld	a,_RDBLK
	ld	(RWCODE),a
	jp	RW1

	;--- READ: Version DOS 2 

READ2:	ld	a,_READ
	ld	(RWCODE),a
	jp	RW2


;--- NOMBRE: WRITE
;      Escribe en un fichero abierto
;    ENTRADA:   B  = Numero de fichero
;               DE = Direccion del bufer
;               HL = Numero de bytes a escribir
;    SALIDA:    A  = 0 -> No hay error
;               A <> 0 -> Error
;                         Se considera error no haber podido escribir
;                         todos los bytes requeridos, es decir,
;                         HL a la entrada <> HL a la salida.
;                         Este error tiene el codigo A=1
;                         tanto en DOS 1 como en DOS 2.
;               HL = Numero de bytes escritos
;    REGISTROS: F
;    LLAMADAS:  CHKDOS2, RW1, RW2

WRITE:	ld	a,(DOS2)
	or	a
	jp	nz,WRITE2

	;--- WRITE: Version DOS 1

WRITE1:	ld	a,_WRBLK
	ld	(RWCODE),a
	jp	RW1

	;--- WRITE: Version DOS 2

WRITE2:	ld	a,_WRITE
	ld	(RWCODE),a
	jp	RW2


;--- RW: Rutina generica de lectura/escritura

	;--- RW: Version DOS 1

RW1:	ld	a,b
	cp	MAXFILES+1
	ld	a,1
	ret	nc
	ld	a,b
	or	a
	ld	a,2
	ret	z

	push	bc,de,ix,iy
	push	hl,de
	ld	hl,FCBS
	ld	de,38
	or	a
	sbc	hl,de
RW1BUC1:	add	hl,de	;HL = Zona en FCBS del fichero B
	djnz	RW1BUC1
	ld	a,(hl)	;A = Identificador de fichero abierto
	ex	(sp),hl
	push	hl

	or	a	;Error si el fichero no esta abierto
	ld	a,2
	jp	z,ENDRW11

	pop	de
	ld	c,_SETDTA
	call	5
	pop	de,hl
	inc	de
	ld	a,(RWCODE)	;Leemos el codigo de lectura o escritura
	ld	c,a
	call	5	;y ejecutamos la llamada

ENDRW1:	pop	iy,ix,de,bc
	ret
ENDRW11:	pop	bc,bc,bc
	jp	ENDRW1

	;--- RW: Version DOS 2

RW2:	;push	bc,de,hl
	ld	a,(RWCODE)	;Leemos el codigo de lectura o escritura
	ld	c,a
	call	5
	ret		;*** PRUEBAS: Devuelve el error real, no el 1

	pop	de
	or	a
	jp	nz,ENDRW2
	push	hl

	sbc	hl,de	;HL = bytes leidos, DE = bytes requeridos
	ld	a,h	;Si HL=DE, no hay error
	or	l	;Si HL<>DE, error 1
	ld	a,0
	pop	hl
	jp	z,ENDRW2
	ld	a,1

ENDRW2:	pop	de,bc
	ret

RWCODE:	db	0	;Codigo de la funcion de lectura/escritura


;--- GET_FILEPART: Dada una cadena x:\ruta\fichero, devuelve
;                  un puntero al nombre del fichero
;    Entrada:  HL = Cadena
;    Salida:   HL = Puntero al nombre del fichero
;              A  = Error (siempre 0 bajo DOS 1)
;    Modifica: AF

GET_FILEPART:	ld	a,(DOS2)
	or	a
	jr	nz,GFP_DOS2

	;--- Version DOS 1: solo puede ser "x:fichero" o "fichero"

GFP_DOS1:	inc	hl
	ld	a,(hl)
	inc	hl
	cp	":"
	ld	a,0
	ret	z
	dec	hl
	dec	hl
	xor	a
	ret

	;--- Version DOS 2

GFP_DOS2:	ex	de,hl
	ld	bc,_PARSE	;B ha de estar a 0
	jp	5


;--- PRINT_DSKERR: Imprime un error de disco.
;    Primero imprime la cadena pasada en DE, y en DOS 1 no hace nada mas.
;    En DOS 2, ademas, imprime una descripcion del error pasado en A.

PRINT_DSKERR:	ld	b,a
	ld	a,(DOS2)
	or	a
	jr	nz,PRDE_DOS2

	;--- Version DOS 1

	ld	c,_STROUT
	call	5
	print	ONE_NL_S
	ret

	;--- Version DOS 2

PRDE_DOS2:	push	bc
	ld	c,_STROUT
	call	5
	ld	e,":"
	ld	c,_CONOUT
	call	5
	ld	e," "
	ld	c,_CONOUT
	call	5

	pop	bc
	ld	de,PARAM_BUFFER
	ld	c,_EXPLAIN
	call	5
	ld	de,PARAM_BUFFER
	call	PRINTZ
	ret


;--- SEND_TFTP: Envia el datagrama que hay en OUT_BUFFER
;    Entrada: BC = Longitud (la guarda en LAST_SND_SIZE)

SEND_TFTP:	ld	hl,(HOST_IP)
	ld	de,(HOST_IP+2)
	ld	ix,(LOCAL_PORT)
	ld	iy,(HOST_PORT)

	ld	(LAST_SND_SIZE),bc
	push	bc
	ld	bc,OUT_BUFFER
	pop	af

	inl	UDP_SEND
	ret


;--- RCV_TFTP: Recibe un paquete TFTP en IN_BUFFER, asegurandose
;    de que la IP y los puertos son correctos y modificandolos si es necesario.
;    Nota: NO comprueba el codigo TFTP del paquete, solo IP y puertos.
;    Devuelve Cy=1 si no hay paquetes disponibles, y BC = Longitud

RCV_TFTP:	ld	hl,IN_BUFFER
	inl	UDP_RCV
	ret	c

	;--- HOST_IP es 0.0.0.0?

	push	ix
	ld	ix,HOST_IP
	ld	a,(ix)
	or	(ix+1)
	or	(ix+2)
	or	(ix+3)
	pop	ix
	jr	nz,RCV_TFTP2

	;--- Si: estabamos esperando una conexion en modo servidor.
	;    Si el puerto de destino es 69, aceptamos el paquete
	;    y establecemos los datos de IP y puertos adecuadamente.

	push	hl,de
	push	iy
	pop	hl
	ld	de,69
	call	COMP
	pop	de,hl
	jr	nz,RCV_TFTP

	ld	(HOST_IP),hl	;Establecemos IP del host como
	ld	(HOST_IP+2),de	;la del paquete que hemos recibido

	ld	(HOST_PORT),ix	;Idem con el puerto del host
RCV_TFTP3:	ld	hl,(TIME)
	ld	de,69	;Puerto de destino=69: OK,
	call	COMP	;y nos ponemos y nuevo puerto
	jr	z,RCV_TFTP3	;aleatorio
	ld	(LOCAL_PORT),hl

	or	a
	ret
RCV_TFTP2:	;

	;--- No: Comprueba que la IP y los puertos
	;    coincidan con los que ya tenemos establecidos.

	push	de	;IP remota, primera mitad
	ld	de,(HOST_IP)
	call	COMP
	pop	de
	jr	nz,RCV_TFTP

	ld	hl,(HOST_IP+2)	;IP remota, segunda mitad
	call	COMP
	jr	nz,RCV_TFTP

	push	iy	;Puerto local
	pop	hl
	ld	de,(LOCAL_PORT)
	call	COMP
	jr	nz,RCV_TFTP

	ld	hl,(HOST_PORT)	;Puerto remoto: Si era 69,
	ld	de,69	;estabamos iniciando la conexion.
	call	COMP	;Entonces establecemos el nuevo puerto
	jr	nz,RCV_TFTP4	;remoto como el que hemos recibido.

	ld	(HOST_PORT),ix
	or	a
	ret

RCV_TFTP4:	push	ix	;Puerto remoto una vez iniciada
	pop	hl	;la conexion: debe coincidir con el
	ld	de,(HOST_PORT)	;que ya teniamos almacenado
	call	COMP
	jp	nz,RCV_TFTP

	;--- Paquete correcto: resetea contador de retransmisiones

RCV_TFTPOK:	call	INIT_RETX

	or	a
	ret


;--- WAIT_TICK: Espera a que pase un intervalo y decrementa RETX_TIMER.
;    Si llega a 0, lo restablece a RETX_TIMER_MAX*60 e incrementa RETX_COUNTER,
;    ademas de reenviar el ultimo paquete enviado.
;    Si el contador de retransmisiones llega a RETX_CNT_MAX,
;    envia un mensaje de error de timeout y devuelve Cy=1.

WAIT_TICK:	inl	WAIT_INT

	;* Ha pasado un intervalo de 1/50 o 1/60 segs

	ld	a,(RETX_TIMER)
	dec	a
	ld	(RETX_TIMER),a
	scf
	ccf
	ret	nz

	;* El temporizador ha llegado a 0: incrementamos contador

	ld	a,RETX_TIMER_MAX*60
	ld	(RETX_TIMER),a

	ld	a,(RETX_COUNTER)
	inc	a
	ld	(RETX_COUNTER),a
	cp	RETX_CNT_MAX
	jr	z,WAIT_TICK_2

	ld	bc,(LAST_SND_SIZE)
	call	SEND_TFTP	;Reenvia ultimo paquete
	scf
	ccf
	ret
WAIT_TICK_2:	;

	;* Intentos agotados: envia error y termina

	call	SEND_TOUTRTT
	print	ABTOUT_S
	scf
	ret


;--- SHOW_TFTPE: Muestra informacion sobre el error recibido en IN_BUFFER;
;    muestra el codigo de error y el mensaje recibido, si lo hay.

SHOW_TFTPE:	print	ERRRCV_S

	ld	a,(IN_BUFFER+3)
	ld	ix,PARAM_BUFFER
	call	BYTE2ASC	;Asume que es de un byte
	ld	(ix)," "
	ld	(ix+1),"-"
	ld	(ix+2)," "
	ld	(ix+3),"$"
	print	PARAM_BUFFER

	ld	de,IN_BUFFER+4
	ld	a,(de)
	or	a
	jr	nz,SHOW_TFTPE2
	ld	de,NOMESSAGE_S	;Cadena a imprimir si no hay mensaje
SHOW_TFTPE2:	call	PRINTZ

	print	ONE_NL_S
	ret


;--- SHOW_PROGRESS: Muestra el progreso del envio/recepcion

SHOW_PROGRESS:	ld	a,(GETPUT)
	or	a
	ld	de,RECEIVED_S
	jr	z,SHOW_PROG2
	ld	de,SENT_S
SHOW_PROG2:	ld	c,_STROUT	;Imprime "Sending" o "Receiving"
	call	5

	ld	de,(LAST_BLKID)
	srl	d
	rr	e	;DE=KBytes recibidos

	ld	hl,PARAM_BUFFER
	ld	b,1
	ld	a,%1000
	call	NUMTOASC
	print	PARAM_BUFFER	;Imprime numero del KBytes

	ld	e,"."
	ld	c,_CONOUT
	call	5

	ld	a,(LAST_BLKID)	;Imprime ".0" o ".5"
	ld	e,"0"
	and	1
	jr	z,SHOW_PROG3
	ld	e,"5"
SHOW_PROG3:	ld	c,_CONOUT
	call	5

	print	BLOCKS_S
	ret


;--- SEND_TOUTERR: Envia un mensaje de error de timeout

SEND_TOUTRTT:	ld	de,TOUT_MSG
	xor	a
	jp	SEND_ERR

TOUT_MSG:	db	"Timeout",0


;--- SEND_DSKERR: Envia un mensaje de error con el error DOS pasado en A.
;    En DOS 1, el mensaje siempre es "Disk error".

SEND_DSKERR:	ld	b,a
	ld	a,(DOS2)
	or	a
	jr	nz,SND_DSKERR2

	;--- DOS 1

	ld	de,DSKERR_S
	jr	SND_DE_COMMON

	;--- DOS 2

SND_DSKERR2:	ld	de,PARAM_BUFFER
	push	de
	ld	c,_EXPLAIN
	call	5
	pop	de

	;--- Comun

SND_DE_COMMON:	ld	a,3	;Error "Allocation exceeded"
	jp	SEND_ERR


;--- SEND_ERR: Rutina generica para el envio de un error.
;    Entrada: A = Codigo de error
;             DE = Mensaje de error, acabado en 0

SEND_ERR:	ld	hl,#0500	;Codigo de paquete de error
	ld	(OUT_BUFFER),hl
	ld	h,a	;Codigo de error pasado
	ld	l,0
	ld	(OUT_BUFFER+2),hl

	push	de
	pop	hl
	call	STRLEN
	inc	bc	;BC = Long. cadena incluyendo el 0 final

	ex	de,hl
	ld	de,OUT_BUFFER+4
	push	bc	;Anexa la cadena al paquete
	ldir

	pop	bc
	inc	bc
	inc	bc
	inc	bc
	inc	bc	;Para que long. incluya cabecera
	jp	SEND_TFTP


;--- FCLOSE: Cierra el fichero cuyo numero esta en FH, si es que esta abierto

FCLOSE:	ld	a,(FH)	;Si FH es 0, no esta abierto
	or	a
	ret	z

	ld	b,a
	call	CLOSE
	xor	a
	ld	(FH),a
	ret


;--- INIT_RETX: Inicializacion de los contadores de retransmision

INIT_RETX:	ld	a,RETX_TIMER_MAX*60
	ld	(RETX_TIMER),a
	ld	a,0
	ld	(RETX_COUNTER),a
	ret


;--- FLUSH_UDP: Borrado de los paquetes UDP antiguos

FLUSH_UDP:	ld	hl,0
	inl	UDP_RCV
	jr	nc,FLUSH_UDP


;--- INIT_TIDS_CLIENT: Inicializacion de los TIDs para modo cliente
;    (para evitar confusiones, descarta el puerto local 69)

INIT_TIDS_CLIENT:	ld	hl,(TIME)
	ld	de,69
	call	COMP
	jr	z,INIT_TIDS_CLIENT
	ld	(LOCAL_PORT),hl
	ld	hl,69
	ld	(HOST_PORT),hl
	ret


;--- CHECK_KEY: Llama a una rutina del DOS para que se pueda
;    detectar la pulsacion de CTRL-C y asi dar oportunidad
;    al usuario de cancelar la transmision.
;    De paso, devuelve A<>0 si se ha pulsado una tecla.

CHECK_KEY:	ld	e,#FF
	ld	c,_DIRIO
	jp	5


;*****************************
;***                       ***
;***  VARIABLES Y CADENAS  ***
;***                       ***
;*****************************

	;--- Variables

INL_SEG1:	db	0
;INL_SEG2:       db      0      ;--- No necesarios
;INL_P3DIR:      dw      0      ;--- en este programa
DOS2:	db	0	;#FF si hay DOS 2
SERVER:	db	0	;#FF si funcionando en modo servidor
HOST_IP:	ds	4	;IP del host remoto
HOST_PORT:	dw	0	;TID para la transferencia
LOCAL_PORT:	dw	0	;TID local
FH:	db	0	;File Handle del fichero abierto
LAST_BLKID:	dw	0	;Ultimo ID de bloque recibido
GETPUT:	db	0	;0 si recibimos, #FF si enviamos
NUMFILES:	db	0	;Numero de ficheros abiertos (DOS 1)
RETX_TIMER:	db	0	;Temporizador de retransmisiones
RETX_COUNTER:	db	0	;Contador de retransmisiones
FILEPART_PNT:	dw	0	;Puntero al nombre del fichero
LAST_SND_SIZE:	dw	0	;Long. ultimo paquete enviado
LAST_RCV_SIZE:	dw	0	;Long. ultimo paquete recibido

	;--- Cadenas

	;* Informacion de uso

PRESENT_S:	db	27,"x5"	;Desactiva cursor
	db	"TFTP Client/Server for InterNestor Lite 1.02",13,10
	db	"By Konami Man, 12-2004",13,10,10,"$"

INFO_S:	db	"Usage:",13,10,10
	db	"* To send a file:",13,10
	db	"  TFTP <host name> S[END]|P[UT] <local filename> [<transfer filename>]",13,10
	db	"  Default for <transfer filename> is <local filename> without the drive/path",13,10,10
	db	"* To receive a file:",13,10
	db	"  TFTP <host name> R[CV]|G[ET] <remote filename> [<local filename>]",13,10
	db	"  Default for <local filename> is <remote filename> without the path",13,10
	db	"  (only if <remote filename> has a valid MSX-DOS path, and only in DOS 2)",13,10,10
	db	"* To run in server mode:",13,10
	db	"  TFTP /S[ERVER]",13,10,"$"

	;* Errores de inicializacion

NOINS_S:	db	"*** InterNestor Lite is not installed",13,10,"$"
NOCON_S:	db	"*** Not connected to Internet",13,10,"$"
INVPAR_S:	db	"*** Invalid parameter",13,10,"$"
MISSPAR_S:	db	"*** Missing parameter(s)",13,10,"$"

	;* Resolucion del nombre de host

RESOLVING_S:	db	"Resolving host name... $"
RESOLVERR_S:	db	13,10,"ERROR "
RESOLVERRC_S:	ds	6	;Deja espacio para "<codigo>: $"
RESOLVOK_S:	db	"OK: "
RESOLVIP_S:	ds	16	;Espacio para "xxx.xxx.xxx.xxx$"
TWO_NL_S:	db	13,10
ONE_NL_S:	db	13,10,"$"

	;* Errores de DNS_Q

DNSQERRS_T:	db	1,"Not connected to Internet$"
	db	4,"No DNS servers available$"
	db	0

	;* Errores de DNS_R

DNSRERRS_T:	db	1,"Query format error$"
	db	2,"Server failure$"
	db	3,"Name error (this host name does not exist)$"
	db	4,"Query type not implemented by the server$"
	db	5,"Query refused by the server$"
	db	16,"Server(s) not responding to queries$"
	db	17,"Total operation timeout expired$"
	db	19,"Internet connection lost$"
	db	20,"Dead-end reply (not containing answers nor redirections)$"
	db	21,"Truncated reply$"
	db	0

	;* Errores durante la ejecucion

ERROPEN_S:	db	"*** Error when opening file$"
ERRCREATE_S:	db	"*** Error when creating file$"
ERRREAD_S:	db	"*** Error when reading from file$"
ERRWRITE_S:	db	"*** Error when writing to file$"
GENERR_S:	db	13,10,"*** Error$"

ERRRCV_S:	db	13,10,"*** Error received: $"
NOMESSAGE_S:	db	"(No message included)",0

ABTOUT_S:	db	13,10,"*** Timeout - Transmission aborted",13,10,"$"

DSKERR_S:	db	"Disk error",0
FNOTF_S:	db	"File not found or invalid path",0

	;* Informacion durante la ejecucion

INSERV_S:	db	13,">>> Now running in server mode. Press any key to exit.",13,10,"$"

RECEIVED_S:	db	13,"Receiving: $"
SENT_S:	db	13,"Sending: $"
BLOCKS_S:	db	" KBytes     $"

RRQSENT_S:	db	"Read request sent...",13,"$"
WRQSENT_S:	db	"Write request sent...",13,"$"

TCOMPLETE_S:	db	13,10,10,"Transfer complete.",13,10,"$"

WAITING_IN_S:	db	13,10,"* Waiting for incoming connection...",13,10,10,"$"
RRQRCVD_S:	db	"Received read request for file $"
WRQRCVD_S:	db	"Received write request for file $"
ERRETURN_S:	db	"Error returned: $"

OCTET_S:	db	"OCTET",0


	;-----------------
	;---  Buferes  ---
	;-----------------

PARAM_BUFFER:	;Para el ultimo parametro extraido
DISK_BUFFER:	equ	PARAM_BUFFER+128	;Bufer generico para operaciones de disco
OUT_BUFFER:	equ	DISK_BUFFER+71	;Para el ultimo paquete enviado
IN_BUFFER:	equ	OUT_BUFFER+520	;Para el ultimo paquete recibido
FCBS:	equ	IN_BUFFER+556	;Para FCBs de ficheros abiertos (DOS 1)
END_BUFFERS:	equ	FCBS+38*MAXFILES
