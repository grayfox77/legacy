NASM 1.1 - B(conami Man, 2-2001
--------------------------------


1. WHAT IS THIS?

tNASMis a C library composed of funtions for performing machine code routines 
calls, with the possiblity of passing registers for input and consult them at 
output. There are five functions: NASCALL, the generic function for 
performing machine code routine call; DOSCALL, to call DOS functions; 
BIOSCALL, to execute BIOS routines; SUBCALL, to execute sub-BIOS routines; 
and EXTCALL, to call extended BIOS.

The complete package of tNASMconsists of the following files:

* tNAS.LIB: The library fileMcontaining the object filesMcorresponding to the 
functions previously listed.

* tNAS.H: FileMcontaining the header for the functions, also the data 
structures necessary for passing and returning register values are defined 
here.

* DOSCODES.H: In this fileMthere are defined the names for all the DOS 2 
functions, as they are in the "MSX DOS 2 Function Codes Specification" 
document. Also the names for all the DOS 2 errors are defined, as they are in 
the "MSX DOS 2 Program Interface Specification" document, but "." are changed 
into "_" since C compiler does not accept names including dots. For this 
reason the names for some errors have been changed, since they coincided with 
the name of any DOS function. Errors with changed names are:

_SEEKE, original name is .SEEK (error 0F3h)
_FOPENE, original name is .FOPEN (error 0CAh)

* tNAS.TXT: Spanish version of this document.

* tNASE.TXT: This document.

* NASCALL.AS, DOSCALL.C, BIOSCALL.C, SUBCALL.C, EXTCALL.C: Source codes for 
tNASMfunctions.


2. STRUCTURES FOR PASSING REGISTERS

All the functions composing tNASMaccept a pointer to a REGSET type structure 
as the last parameters. This structure contains the values which will be 
passed to the called routine through the CPU registers, and after the 
execution, it contains the values returned in the registers by the routine. 
REGSET structure is defined in tNAS.H fileM(where also uint and uchar types 
are defined, as "unsigned int" and "unsigned char" respectively) in the 
following way:

typedef struct{
	uchar f;
	uchar a;
	uint bc;
	uint de;
	uint hl;
	uint ix;
	uint iy;
} regset;

tNAS.H defines also an alternative form for this structure, which treats 
registers individually, not by pairs like REGSET:

typedef struct{
	uchar f;
	uchar a;
	uchar c;
	uchar b;
	uchar e;
	uchar d;
	uchar l;
	uchar h;
	uchar ixl;
	uchar ixh;
	uchar iyl;
	uchar iyh;
} regset8;

Although tNASMfunctions are prepared to receive a pointer to a REGSET 
structure as parameter, it is also possible to pass a pointer to a REGSET8 
structure, performing a cast to avoid a warning being generated by the 
compiler. That is, it is possible to do

regset8 regs8;
...
asmcall (dir, (regset*) &regs8);

instead of

regset regs;
...
asmcall (dir, &regs)

However most times what we want is to mix both structures, that is, to manage 
some registers as pairs and some others as single registers. A solution for 
this is to define a REGSET or REGSET8 structure, and access to registers of 
contrary type by multiplications, divisions and rotations. ButMthere is an 
easier way to do same: define a structure of any type, next define a 
pointer to a structure of the contrary type, and make this pointer to point 
to the structure previously defined. That is:

regset regs;
regset8* regs8 = (regset8*) &regs;

thus we can access the register pairs with the "." operator, and the single 
registers with the "->" operator:

regs.de = ... /* UINT type value */
regs8->b = ... /* UCHAR type value */

tote that A and F registers are defined separately both in REGSET and in 
REGSET8.

Finally, if actually we don't want to pass any input data through registers 
nor are interested in the registers output values, we can specify NULL 
instead of a pointer to a REGSET or REGSET8 structure. When doing this, input 
registers will have an aleatory value, and output registers values will be 
simply discarded.


3. FUNCTIONS DESCRPITON

text, the tNASMfunctions are described and an example is provided for each 
one.


* NASCALL

void asmcall(void* address, regset* registers)

This is the basic function for calling a machine code routine placed in 
"address", interacting with the registers structure passed as explained in 
previous section. NULL can be used instead of "registers" to specify that we 
don't want to pass any concrete value for registers at input nor are 
interested in the output values.

All the other tNASMfunctions actually work by calling NASCALL, so their 
source codes serve as examples for the use of NASCALL.


* DOSCALL

void doscall(uchar function, regset* registers)

This function calls the specified DOS function, interacting with the 
registers structure passed as explained in previous section. NULL can be used 
instead of "registers" to specify that we don't want to pass any concrete 
value for registers at input nor are interested in the output values.

Actually this function simply copies the DOS function code into the C 
register of "registers", and then calls to 0005h address via NASCALL. If NULL 
is specified instead of "registers", a register set is temporarily created, 
and destroyed after the execution.

Example: the following program shows the system date and time, which are 
obtained via the DOS functions _GDATE (2Ah) and _GTIME (2Ch).

-----
#include "stdio.h"
#include "nasm.h"
#include "doscodes.h"

regset rdate;	/* Registers for calling _GDATE */
regset rtime;	/* Registers for calling _GTIME */
regset8* rdate8 = (regset8*) &rdate;
regset8* rtime8 = (regset8*) &rtime;

char* months[]= {"January","February","March","April","May","Juny","July",
		 "August","September","October","November","December"};

char* dows[]=	{"Monday","Tuesday","Wednesday","Thursday","Friday",
		 "Saturday","Sunday"};

main()
{

doscall (_GDATE, &rdate);
doscall (_GTIME, &rtime);

printf ("\n\rDate and time:\n\n\r");
printf ("%s, %s %dth %d; %d:%02d:%02d.\n\r",
	dows[(rdate.a)-1],	/* Day of week */
	months[(rdate8->d)-1],	/* Month */
	rdate8->e,		/* Day of month */
	rdate.hl,		/* Year */
	rtime8->h,		/* Hour */
	rtime8->l,		/* Minute */
	rtime8->d		/* Second */
        );
}
-----


* BIOSCALL

void bioscall(void* address, regset* registers)

This function calls the specified BIOS routine, interacting with the 
registers structure passed as explained in previous section. NULL can be used 
instead of "registers" to specify that we don't want to pass any concrete 
value for registers at input nor are interested in the output values.

Actually this function simply copies the BIOS routine address into the IX
register of "registers", loads the content of 0FCC1 address into IYh, and 
then calls to 001Ch address via NASCALL. If NULL is specified instead of 
"registers", a register set is temporarily created, and destroyed after the 
execution.

Example: the following function sets the graphic mode specified in the 
parameter "mode", using BIOS function CHGMOD (005Fh). It returns 1 if "mode" 
is invalid (not in the range 0-8), otherwise returns 0.

-----
#include "nasm.h"
#include "doscodes.h"

#define CHGMOD ((void*)0x005F)

int screen(int mode)
{
	regset regs;
	if(mode<0 || mode>8) return 1;
	regs.a = (uchar) mode;
	bioscall (CHGMOD, &regs);
	return 0;
}
-----


* SUBCALL

void subcall(void* address, regset* registers)

This function calls the specified sub-BIOS routine, interacting with the 
registers structure passed as explained in previous section. NULL can be used 
instead of "registers" to specify that we don't want to pass any concrete 
value for registers at input nor are interested in the output values.

Actually this function simply copies the sub-BIOS routine address into the IX
register of "registers", loads the content of 0FAF8 address into IYh, and 
then calls to 001Ch address via NASCALL. If NULL is specified instead of 
"registers", a register set is temporarily created, and destroyed after the 
execution.

Example: the following funtion sets the RGB components for the given color, 
using sub-BIOS routine SETPLT (014Dh). If any parameter is invalid, 1 is 
returned, otherwise 0 is returned.

-----
#include "nasm.h"
#include "doscodes.h"

#define SETPLT ((void*)0x014D)

int setpal(int color, int red, int green, int blue)
{
	regset8 regs8;
	if(color>15 || (red|green|blue)>7) return 1;
	regs8.d = (uchar) color;
	regs8.a = (uchar) (red<<4)|blue;
	regs8.e = (uchar) green;
	subcall (SETPLT, (regset*) &regs8);
	return 0;
}
-----


* EXTCALL

void extcall(uchar device, uchar function, regset* registers)

This function calls the specified extended BIOS function for the specified 
device, interacting with the registers structure passed as explained in 
previous section. NULL can be used instead of "registers" to specify that we 
don't want to pass any concrete value for registers at input nor are 
interested in the output values.

Actually this function simply copies the device number into D register of 
"registers", also the function number in the E register, and then calls to 
0FFCAh address via NASCALL. If NULL is specified instead of "registers", a 
register set is temporarily created, and destroyed after the execution.

Example: the following program shows information aboutMthe mapped memory 
present in the system (total, free an reserved segments), which obtains via 
DOS 2 mapper support routines call (extended BIOS, device 4).

-----
#include "stdio.h"
#include "nasm.h"
#include "doscodes.h"

regset regs;
int total=0;
int free=0;
int system=0;
int user=0;
int mappers=0;
uchar* table;

main()
{

if (!((*(char*)0xFB20)&1))
{
	printf("Error: no extended BIOS found.\n\r");
	doscall(_TERM0, NULL);	/* Finishes program execution */
}

regs.a=0;
extcall(4, 1, &regs);	/* Obtain mappers variables table */
if (!regs.a)
{
	printf("Error: no mapper support routines found.\n\r");
	doscall(_TERM0, NULL);
}

table = (uchar*) regs.hl;
while(table[0]) 	/* One step per mapper */
{
	mappers++;
	total+= table[1];
	free+= table[2];
	system+= table[3];
	user+= table[4];
	table+= 8;
}

printf("\n\rNumber of mappers: %d\n\r", mappers);
printf("Total memory: %dK\n\r", total*16);
printf("Free memory: %dK\n\r", free*16);
printf("System reserved memory: %dK\n\r", system*16);
printf("User reserved memory: %dK\n\r", user*16);
}
-----


4. THE USUAL BULLSHIT

tNASMis freeware, so distribute it as you want, but please distribute all the 
files (the ones listed in section 1) and if you do any modification please 
explain it in a separate text file.

If you want to kick me or congratulate me or blah, blah... contact me at 
konamiman@konamiman.com, and visit my home page at http://www.konamiman.com

And Kyoko is the best.


5. VERSION INFORMATION

* 1.1 (14-2-2001): Improved NASCALL version, this one can be called 
recursively. This allows the use of tNASMfunctions from user disk error 
handling routines (defined with DOS function _DEFERR, 64h) and from user 
abort exit routines (defined with DOS function _DEFAB, 63h).

alu